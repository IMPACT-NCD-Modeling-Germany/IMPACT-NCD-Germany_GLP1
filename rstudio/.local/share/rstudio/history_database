1751740262644:# Load packages
1751740262644:source("./global.R")
1751740281437:# Load packages
1751740281437:source("./global.R")
1751740515638:install.packages("pillar")
1751740532654:# Load packages
1751740532654:source("./global.R")
1751740574898:cat("Initialising IMPACTncd_Ger model...\n\n")
1751740575998:if (interactive() && !nzchar(system.file(package = "CKutils"))) {
1751740575998:if (!nzchar(system.file(package = "remotes"))) install.packages("remotes")
1751740575998:remotes::install_github("ChristK/CKutils", force = TRUE, upgrade = "never")
1751740575999:}
1751740577686:library(CKutils)
1751740578460:options(rgl.useNULL = TRUE)  # suppress error by demography in rstudio server
1751740578723:options(future.fork.enable = TRUE) # TODO remove for production
1751740578906:options(future.rng.onMisuse = "ignore") # Remove false warning
1751740579089:options(datatable.verbose = FALSE)
1751740579288:options(datatable.showProgress = FALSE)
1751740579879:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751740607643:install.packages("ggplot2")
1751740619742:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751740635582:library(ggplot2)
1751740661633:install.packages("pillar")
1751740683757:install.packages("tidyverse")
1751740715795:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751740727685:library(ggplot2)
1751747929116:cat("Initialising IMPACTncd_Ger model...\n\n")
1751747931142:if (interactive() && !nzchar(system.file(package = "CKutils"))) {
1751747931142:if (!nzchar(system.file(package = "remotes"))) install.packages("remotes")
1751747931142:remotes::install_github("ChristK/CKutils", force = TRUE, upgrade = "never")
1751747931142:}
1751747932454:library(CKutils)
1751747934094:options(rgl.useNULL = TRUE)  # suppress error by demography in rstudio server
1751747934325:options(future.fork.enable = TRUE) # TODO remove for production
1751747934542:options(future.rng.onMisuse = "ignore") # Remove false warning
1751747934756:options(datatable.verbose = FALSE)
1751747935191:options(datatable.showProgress = FALSE)
1751747935703:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748028025:getOption("repos")
1751748177268:getOption("repos")
1751748180757:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748188297:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748219039:install.packages("pillar")
1751748245256:install.packages("pillar", repos = "https://packagemanager.rstudio.com/all/__linux__/focal/latest")
1751748253322:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748342309:install.packages("igraph", repos = "https://packagemanager.rstudio.com/all/__linux__/focal/latest")
1751748354475:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748363137:install.packages("igraph", repos = "https://packagemanager.rstudio.com/all/__linux__/focal/latest")
1751748368733:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748424570:install.packages("igraph", repos = "https://cloud.r-project.org/")
1751748634197:dependencies
1751748638675:options(repos = c(CRAN = "https://cloud.r-project.org/"))
1751748638943:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748705653:library(igraph)
1751748720535:remove.packages("igraph")
1751748728492:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748908053:cat("Initialising IMPACTncd_Ger model...\n\n")
1751748908054:if (interactive() && !nzchar(system.file(package = "CKutils"))) {
1751748908054:if (!nzchar(system.file(package = "remotes"))) install.packages("remotes")
1751748908054:remotes::install_github("ChristK/CKutils", force = TRUE, upgrade = "never")
1751748908054:}
1751748908056:library(CKutils)
1751748908737:options(rgl.useNULL = TRUE)  # suppress error by demography in rstudio server
1751748908738:options(future.fork.enable = TRUE) # TODO remove for production
1751748908738:options(future.rng.onMisuse = "ignore") # Remove false warning
1751748908738:options(datatable.verbose = FALSE)
1751748908738:options(datatable.showProgress = FALSE)
1751748908738:options(repos = c(CRAN = "https://cloud.r-project.org/"))
1751748908738:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751748915772:if (interactive()) {
1751748915773:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1751748915773:if (file.exists(snfile)) snapshot <- changedFiles(qread(snfile))
1751748915773:if (!nzchar(system.file(package = "IMPACTncdGer")) ||
1751748915773:!file.exists(snfile) || any(nzchar(snapshot$added),
1751748915773:nzchar(snapshot$deleted),
1751748915773:nzchar(snapshot$changed))) {
1751748915773:if (!nzchar(system.file(package = "remotes")))
1751748915773:install.packages("remotes")
1751748915774:if (nzchar(system.file(package = "roxygen2")))
1751748915774:roxygen2::roxygenise("./Rpackage/IMPACTncd_Ger_model_pkg/", clean = TRUE)
1751748915774:detach_package <- function(pkg, character.only = FALSE)
1751748915774:{
1751748915774:if(!character.only)
1751748915774:{
1751748915774:pkg <- deparse(substitute(pkg))
1751748915774:}
1751748915775:search_item <- paste("package", pkg, sep = ":")
1751748915775:while(search_item %in% search())
1751748915775:{
1751748915775:detach(search_item, unload = TRUE, character.only = TRUE)
1751748915775:}
1751748915775:}
1751748915775:detach_package(IMPACTncdGer)
1751748915775:remotes::install_local("./Rpackage/IMPACTncd_Ger_model_pkg/",
1751748915776:force = TRUE,
1751748915776:upgrade = "never")
1751748915776:if (file.exists(snfile)) file.remove(snfile)
1751748915776:qsave(
1751748915776:fileSnapshot(
1751748915776:"./Rpackage/IMPACTncd_Ger_model_pkg/",
1751748915776:timestamp = NULL,
1751748915777:md5sum = TRUE,
1751748915777:recursive = TRUE
1751748915777:),
1751748915777:snfile
1751748915777:)
1751748915777:}
1751748915777:}
1751749333735:.Last.error
1751749559684:interactive()
1751749574332:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1751749621868:file.exists(snfile)
1751749655685:snapshot <- changedFiles(qread(snfile))
1751749717626:is_docker <- file.exists("/.dockerenv")
1751749717626:print(is_docker)
1751749773943:if (file.exists("/.dockerenv")) {file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")}
1751749790996:file.exists("/.dockerenv")
1751749802371:if (file.exists("/.dockerenv")) file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")
1751749820545:file.exists("/.dockerenv")
1751749914542:file.exists("/.dockerenv") && file.exists(snfile)
1751749922103:if (interactive()) {
1751749922103:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1751749922103:if (file.exists("/.dockerenv") && file.exists(snfile)) file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")
1751749922104:if (file.exists(snfile)) snapshot <- changedFiles(qread(snfile))
1751749922104:if (!nzchar(system.file(package = "IMPACTncdGer")) ||
1751749922104:!file.exists(snfile) || any(nzchar(snapshot$added),
1751749922104:nzchar(snapshot$deleted),
1751749922104:nzchar(snapshot$changed))) {
1751749922104:if (!nzchar(system.file(package = "remotes")))
1751749922104:install.packages("remotes")
1751749922105:if (nzchar(system.file(package = "roxygen2")))
1751749922105:roxygen2::roxygenise("./Rpackage/IMPACTncd_Ger_model_pkg/", clean = TRUE)
1751749922105:detach_package <- function(pkg, character.only = FALSE)
1751749922105:{
1751749922105:if(!character.only)
1751749922105:{
1751749922105:pkg <- deparse(substitute(pkg))
1751749922105:}
1751749922105:search_item <- paste("package", pkg, sep = ":")
1751749922106:while(search_item %in% search())
1751749922106:{
1751749922106:detach(search_item, unload = TRUE, character.only = TRUE)
1751749922106:}
1751749922106:}
1751749922106:detach_package(IMPACTncdGer)
1751749922106:remotes::install_local("./Rpackage/IMPACTncd_Ger_model_pkg/",
1751749922106:force = TRUE,
1751749922107:upgrade = "never")
1751749922107:if (file.exists(snfile)) file.remove(snfile)
1751749922107:qsave(
1751749922107:fileSnapshot(
1751749922107:"./Rpackage/IMPACTncd_Ger_model_pkg/",
1751749922107:timestamp = NULL,
1751749922108:md5sum = TRUE,
1751749922108:recursive = TRUE
1751749922108:),
1751749922108:snfile
1751749922108:)
1751749922108:}
1751749922108:}
1751749952847:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751749971930:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751749984571:options(repos = c(CRAN = "https://cloud.r-project.org/"))
1751749984855:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751750004036:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751750157085:dependencies(yaml::read_yaml("./dependencies.yaml"))
1751750183530:install.packages("ggpubr")
1756289151386:getwd()
1756289176363:getwd()
1756289188753:list.dirs()
1756289209736:source("./global.R")
1756289275397:install.packages("plotly")
1756289365934:cat("Initialising IMPACTncd_Ger model...\n\n")
1756289366568:if (interactive() && !nzchar(system.file(package = "CKutils"))) {
1756289366589:if (!nzchar(system.file(package = "remotes"))) install.packages("remotes")
1756289366610:remotes::install_github("ChristK/CKutils", force = TRUE, upgrade = "never")
1756289366632:}
1756289367321:library(CKutils)
1756289368049:options(rgl.useNULL = TRUE)  # suppress error by demography in rstudio server
1756289368658:options(future.fork.enable = TRUE) # TODO remove for production
1756289369334:options(future.rng.onMisuse = "ignore") # Remove false warning
1756289369492:options(datatable.verbose = FALSE)
1756289369664:options(datatable.showProgress = FALSE)
1756289369827:options(repos = c(CRAN = "https://cloud.r-project.org/"))
1756289384808:dependencies(yaml::read_yaml("./dependencies.yaml"))
1756289397810:if (interactive()) {
1756289397834:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1756289397858:if (file.exists("/.dockerenv") && file.exists(snfile)) file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")
1756289397891:if (file.exists(snfile)) snapshot <- changedFiles(qread(snfile))
1756289397924:if (!nzchar(system.file(package = "IMPACTncdGer")) ||
1756289397945:!file.exists(snfile) || any(nzchar(snapshot$added),
1756289397968:nzchar(snapshot$deleted),
1756289397991:nzchar(snapshot$changed))) {
1756289398014:if (!nzchar(system.file(package = "remotes")))
1756289398042:install.packages("remotes")
1756289398070:if (nzchar(system.file(package = "roxygen2")))
1756289398094:roxygen2::roxygenise("./Rpackage/IMPACTncd_Ger_model_pkg/", clean = TRUE)
1756289398115:detach_package <- function(pkg, character.only = FALSE)
1756289398137:{
1756289398159:if(!character.only)
1756289398180:{
1756289398199:pkg <- deparse(substitute(pkg))
1756289398217:}
1756289398235:search_item <- paste("package", pkg, sep = ":")
1756289398252:while(search_item %in% search())
1756289398270:{
1756289398287:detach(search_item, unload = TRUE, character.only = TRUE)
1756289398304:}
1756289398322:}
1756289398340:detach_package(IMPACTncdGer)
1756289398358:remotes::install_local("./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289398376:force = TRUE,
1756289398394:upgrade = "never")
1756289398422:if (file.exists(snfile)) file.remove(snfile)
1756289398441:qsave(
1756289398459:fileSnapshot(
1756289398477:"./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289398495:timestamp = NULL,
1756289398513:md5sum = TRUE,
1756289398530:recursive = TRUE
1756289398548:),
1756289398568:snfile
1756289398587:)
1756289398606:}
1756289398625:}
1756289491124:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1756289492561:if (file.exists("/.dockerenv") && file.exists(snfile)) file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")
1756289493444:if (file.exists(snfile)) snapshot <- changedFiles(qread(snfile))
1756289495657:if (!nzchar(system.file(package = "IMPACTncdGer")) ||
1756289495685:!file.exists(snfile) || any(nzchar(snapshot$added),
1756289495727:nzchar(snapshot$deleted),
1756289495763:nzchar(snapshot$changed))) {
1756289495795:if (!nzchar(system.file(package = "remotes")))
1756289495830:install.packages("remotes")
1756289495866:if (nzchar(system.file(package = "roxygen2")))
1756289495899:roxygen2::roxygenise("./Rpackage/IMPACTncd_Ger_model_pkg/", clean = TRUE)
1756289495934:detach_package <- function(pkg, character.only = FALSE)
1756289495968:{
1756289496001:if(!character.only)
1756289496035:{
1756289496063:pkg <- deparse(substitute(pkg))
1756289496107:}
1756289496145:search_item <- paste("package", pkg, sep = ":")
1756289496195:while(search_item %in% search())
1756289496231:{
1756289496271:detach(search_item, unload = TRUE, character.only = TRUE)
1756289496312:}
1756289496348:}
1756289496383:detach_package(IMPACTncdGer)
1756289496417:remotes::install_local("./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289496451:force = TRUE,
1756289496485:upgrade = "never")
1756289496533:if (file.exists(snfile)) file.remove(snfile)
1756289496563:qsave(
1756289496594:fileSnapshot(
1756289496623:"./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289496653:timestamp = NULL,
1756289496683:md5sum = TRUE,
1756289496712:recursive = TRUE
1756289496740:),
1756289496769:snfile
1756289496798:)
1756289496826:}
1756289562976:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1756289563217:if (file.exists("/.dockerenv") && file.exists(snfile)) file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")
1756289563469:if (file.exists(snfile)) snapshot <- changedFiles(qread(snfile))
1756289563729:if (!nzchar(system.file(package = "IMPACTncdGer")) ||
1756289563753:!file.exists(snfile) || any(nzchar(snapshot$added),
1756289563776:nzchar(snapshot$deleted),
1756289563796:nzchar(snapshot$changed))) {
1756289563821:if (!nzchar(system.file(package = "remotes")))
1756289563840:install.packages("remotes")
1756289563862:if (nzchar(system.file(package = "roxygen2")))
1756289563882:roxygen2::roxygenise("./Rpackage/IMPACTncd_Ger_model_pkg/", clean = TRUE)
1756289563903:detach_package <- function(pkg, character.only = FALSE)
1756289563921:{
1756289563941:if(!character.only)
1756289563961:{
1756289563980:pkg <- deparse(substitute(pkg))
1756289564003:}
1756289564027:search_item <- paste("package", pkg, sep = ":")
1756289564051:while(search_item %in% search())
1756289564072:{
1756289564094:detach(search_item, unload = TRUE, character.only = TRUE)
1756289564114:}
1756289564134:}
1756289564153:detach_package(IMPACTncdGer)
1756289564173:remotes::install_local("./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289564195:force = TRUE,
1756289564216:upgrade = "never")
1756289564249:if (file.exists(snfile)) file.remove(snfile)
1756289564269:qsave(
1756289564289:fileSnapshot(
1756289564308:"./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289564328:timestamp = NULL,
1756289564351:md5sum = TRUE,
1756289564370:recursive = TRUE
1756289564390:),
1756289564410:snfile
1756289564429:)
1756289564448:}
1756289565357:if (interactive()) {
1756289565380:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1756289565401:if (file.exists("/.dockerenv") && file.exists(snfile)) file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")
1756289565449:if (file.exists(snfile)) snapshot <- changedFiles(qread(snfile))
1756289565481:if (!nzchar(system.file(package = "IMPACTncdGer")) ||
1756289565502:!file.exists(snfile) || any(nzchar(snapshot$added),
1756289565522:nzchar(snapshot$deleted),
1756289565542:nzchar(snapshot$changed))) {
1756289565563:if (!nzchar(system.file(package = "remotes")))
1756289565583:install.packages("remotes")
1756289565602:if (nzchar(system.file(package = "roxygen2")))
1756289565622:roxygen2::roxygenise("./Rpackage/IMPACTncd_Ger_model_pkg/", clean = TRUE)
1756289565640:detach_package <- function(pkg, character.only = FALSE)
1756289565659:{
1756289565676:if(!character.only)
1756289565695:{
1756289565719:pkg <- deparse(substitute(pkg))
1756289565742:}
1756289565762:search_item <- paste("package", pkg, sep = ":")
1756289565782:while(search_item %in% search())
1756289565801:{
1756289565819:detach(search_item, unload = TRUE, character.only = TRUE)
1756289565838:}
1756289565856:}
1756289565877:detach_package(IMPACTncdGer)
1756289565897:remotes::install_local("./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289565917:force = TRUE,
1756289565937:upgrade = "never")
1756289565969:if (file.exists(snfile)) file.remove(snfile)
1756289565987:qsave(
1756289566009:fileSnapshot(
1756289566032:"./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289566053:timestamp = NULL,
1756289566073:md5sum = TRUE,
1756289566091:recursive = TRUE
1756289566109:),
1756289566128:snfile
1756289566149:)
1756289566173:}
1756289566198:}
1756289596154:if (interactive()) {
1756289596184:snfile <- "./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs"
1756289596212:if (file.exists("/.dockerenv") && file.exists(snfile)) file.remove("./Rpackage/.IMPACTncd_Ger_model_pkg_snapshot.qs")
1756289596269:if (file.exists(snfile)) snapshot <- changedFiles(qread(snfile))
1756289596311:if (!nzchar(system.file(package = "IMPACTncdGer")) ||
1756289596332:!file.exists(snfile) || any(nzchar(snapshot$added),
1756289596352:nzchar(snapshot$deleted),
1756289596374:nzchar(snapshot$changed))) {
1756289596397:if (!nzchar(system.file(package = "remotes")))
1756289596420:install.packages("remotes")
1756289596441:if (nzchar(system.file(package = "roxygen2")))
1756289596462:roxygen2::roxygenise("./Rpackage/IMPACTncd_Ger_model_pkg/", clean = TRUE)
1756289596483:detach_package <- function(pkg, character.only = FALSE)
1756289596503:{
1756289596524:if(!character.only)
1756289596546:{
1756289596567:pkg <- deparse(substitute(pkg))
1756289596597:}
1756289596625:search_item <- paste("package", pkg, sep = ":")
1756289596651:while(search_item %in% search())
1756289596677:{
1756289596703:detach(search_item, unload = TRUE, character.only = TRUE)
1756289596722:}
1756289596743:}
1756289596765:detach_package(IMPACTncdGer)
1756289596788:remotes::install_local("./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289596809:force = TRUE,
1756289596831:upgrade = "never")
1756289596861:if (file.exists(snfile)) file.remove(snfile)
1756289596881:qsave(
1756289596899:fileSnapshot(
1756289596918:"./Rpackage/IMPACTncd_Ger_model_pkg/",
1756289596937:timestamp = NULL,
1756289596958:md5sum = TRUE,
1756289596977:recursive = TRUE
1756289596997:),
1756289597017:snfile
1756289597037:)
1756289597056:}
1756289597076:}
1756289675176:install.packages("Matrix")
1756289680570:install.packages("Matrix")
1756292961610:cat("Initialising IMPACTncd_Ger model...\n\n")
1756292962237:if (interactive() && !nzchar(system.file(package = "CKutils"))) {
1756292962324:if (!nzchar(system.file(package = "remotes"))) install.packages("remotes")
1756292962381:remotes::install_github("ChristK/CKutils", force = TRUE, upgrade = "never")
1756292962439:}
1756292963349:library(CKutils)
1756292964094:options(rgl.useNULL = TRUE)  # suppress error by demography in rstudio server
1756292964622:options(future.fork.enable = TRUE) # TODO remove for production
1756292964796:options(future.rng.onMisuse = "ignore") # Remove false warning
1756292964941:options(datatable.verbose = FALSE)
1756292965067:options(datatable.showProgress = FALSE)
1756292965403:options(repos = c(CRAN = "https://cloud.r-project.org/"))
1756292965727:dependencies(yaml::read_yaml("./dependencies.yaml"), verbose = TRUE, quiet = FALSE)
1756293053007:dependencies(yaml::read_yaml("./dependencies.yaml"), verbose = TRUE, quiet = FALSE)
1756293089123:library(mc2d)
1756293103431:install.packages("mc2d")
1756293199163:options(repos = c(CRAN = "https://cran.microsoft.com/snapshot/2022-04-01/")
1756293203173:options(repos = c(CRAN = "https://cran.microsoft.com/snapshot/2022-04-01/"))
1756293204274:options(repos = c(CRAN = "https://cran.microsoft.com/snapshot/2022-04-01/"))
1756293219775:install.packages("Matrix")
1756303943296:source("./global.R")
1756304040142:source("./global.R")
1756304062190:cat("Initialising IMPACTncd_Ger model...\n\n")
1756304069331:library(CKutils_Test)
1756304113050:cat("Initialising IMPACTncd_Ger model...\n\n")
1756304113383:if (interactive() && !nzchar(system.file(package = "CKutils"))) {
1756304113440:if (!nzchar(system.file(package = "remotes"))) install.packages("remotes")
1756304113482:remotes::install_github("kalleEF/CKutils_Test", force = TRUE, upgrade = "never")
1756304113533:}
1756304903461:cat("Initialising IMPACTncd_Ger model...\n\n")
1756304903688:if (interactive() && !nzchar(system.file(package = "CKutils"))) {
1756304903716:if (!nzchar(system.file(package = "remotes"))) install.packages("remotes")
1756304903744:remotes::install_github("ChristK/CKutils", force = TRUE, upgrade = "never")
1756304903771:}
1756724939110:source("./global.R")
1756725069762:design <- Design$new("./inputs/sim_design.yaml")
1756725069826:# RR ----
1756725069827:# Create a named list of Exposure objects for the files in ./inputs/RR
1756725069827:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756725069832:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756725073628:names(RR) <- sapply(RR, function(x) x$get_name())
1756725073630:invisible(future_lapply(RR, function(x) {
1756725073630:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756725073631:},
1756725073631:future.seed = 627524136L))
1756725075944:# # NOTE smooth cannot be exported to Design for now, because the first time
1756725075944:# # this parameter changes we need logic to overwrite unsmoothed files
1756725075944:rm(fl)
1756725075945:#
1756725075945:# # Generate diseases ----
1756725075945:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756725075945:x[["design_"]] <- design
1756725075946:x[["RR"]] <- RR
1756725075946:do.call(Disease$new, x)
1756725075946:})
1756725179261:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756725179262:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756725179262:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756725179262:scenario_suffix_for_pop <- scenario_name
1756725179262:list(
1756725179262:"exposures"          = design_$sim_prm$exposures,
1756725179263:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756725179263:"scenario"           = scenario_name,
1756725179263:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756725179263:"init_year"          = design_$sim_prm$init_year,
1756725179263:"pids"               = "pid",
1756725179264:"years"              = "year",
1756725179264:"ages"               = "age",
1756725179264:"ageL"               = design_$sim_prm$ageL,
1756725179264:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756725179264:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756725179265:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756725179265:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756725179265:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756725179265:)
1756725179265:}
1756725179266:# sim <- SynthPop$new(0L, design)
1756725179266:# sim$write_synthpop(1:500)
1756725179266:# sim$delete_synthpop(NULL)
1756725179266:# ll <- sim$gen_synthpop_demog(design)
1756725179267:#TODO include informative error to check whether exposure table is matching data
1756725179267:sp  <- SynthPop$new(1L, design)
1756731532656:source("./global.R")
1756731589762:source("./global.R")
1756731708065:getwd()
1756731783605:source("./global.R")
1756731890370:design <- Design$new("./inputs/sim_design_docker.yaml")
1756731956511:# Create a named list of Exposure objects for the files in ./inputs/RR
1756731956512:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756731956516:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756731957934:names(RR) <- sapply(RR, function(x) x$get_name())
1756731957935:invisible(future_lapply(RR, function(x) {
1756731957935:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756731957936:},
1756731957936:future.seed = 627524136L))
1756731959478:# # NOTE smooth cannot be exported to Design for now, because the first time
1756731959478:# # this parameter changes we need logic to overwrite unsmoothed files
1756731959478:rm(fl)
1756731959478:#
1756731959478:# # Generate diseases ----
1756731959479:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756731959479:x[["design_"]] <- design
1756731959479:x[["RR"]] <- RR
1756731959479:do.call(Disease$new, x)
1756731959479:})
1756732039594:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756732039595:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756732039595:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756732039595:scenario_suffix_for_pop <- scenario_name
1756732039595:list(
1756732039595:"exposures"          = design_$sim_prm$exposures,
1756732039595:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756732039596:"scenario"           = scenario_name,
1756732039596:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756732039596:"init_year"          = design_$sim_prm$init_year,
1756732039596:"pids"               = "pid",
1756732039596:"years"              = "year",
1756732039596:"ages"               = "age",
1756732039597:"ageL"               = design_$sim_prm$ageL,
1756732039597:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756732039597:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756732039597:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756732039597:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756732039597:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756732039598:)
1756732039598:}
1756732039598:# sim <- SynthPop$new(0L, design)
1756732039598:# sim$write_synthpop(1:500)
1756732039599:# sim$delete_synthpop(NULL)
1756732039599:# ll <- sim$gen_synthpop_demog(design)
1756732039599:#TODO include informative error to check whether exposure table is matching data
1756732039599:sp  <- SynthPop$new(1L, design)
1756732137493:lapply(diseases, function(x) {   # run all the functions on all the diseases
1756732137493:print(x$name)
1756732137494:x$gen_parf(sp, design)$
1756732137494:set_init_prvl(sp, design)$
1756732137494:set_rr(sp, design)$
1756732137494:set_incd_prb(sp, design)$
1756732137494:set_dgns_prb(sp, design)$
1756732137495:set_mrtl_prb(sp, design)
1756732137495:})
1756732194727:transpose(sp$pop[, lapply(.SD, anyNA)], keep.names = "rn")[(V1)] # look for NAs, if NAs, debug
1756732202769:# qsave(sp, "./simulation/tmp.qs")
1756732202769:# sp <- qread("./simulation/tmp.qs")
1756732202770:l <- mk_scenario_init2("", diseases, sp, design)   # define an empty scenario
1756732203602:simcpp(sp$pop, l, sp$mc) # the actual simulation happens here, flips all the coins
1756735315235:source("./global.R")
1756735402967:design <- Design$new("./inputs/sim_design_docker.yaml")
1756735417850:# Create a named list of Exposure objects for the files in ./inputs/RR
1756735417850:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756735417854:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756735419336:names(RR) <- sapply(RR, function(x) x$get_name())
1756735419341:invisible(future_lapply(RR, function(x) {
1756735419341:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756735419342:},
1756735419342:future.seed = 627524136L))
1756735421738:# # NOTE smooth cannot be exported to Design for now, because the first time
1756735421739:# # this parameter changes we need logic to overwrite unsmoothed files
1756735421739:rm(fl)
1756735421739:#
1756735421739:# # Generate diseases ----
1756735421739:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756735421739:x[["design_"]] <- design
1756735421739:x[["RR"]] <- RR
1756735421740:do.call(Disease$new, x)
1756735421740:})
1756735509943:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756735509944:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756735509944:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756735509944:scenario_suffix_for_pop <- scenario_name
1756735509944:list(
1756735509945:"exposures"          = design_$sim_prm$exposures,
1756735509945:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756735509945:"scenario"           = scenario_name,
1756735509945:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756735509945:"init_year"          = design_$sim_prm$init_year,
1756735509946:"pids"               = "pid",
1756735509946:"years"              = "year",
1756735509947:"ages"               = "age",
1756735509947:"ageL"               = design_$sim_prm$ageL,
1756735509947:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756735509947:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756735509947:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756735509947:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756735509948:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756735509948:)
1756735509948:}
1756735509949:# sim <- SynthPop$new(0L, design)
1756735509949:# sim$write_synthpop(1:500)
1756735509949:# sim$delete_synthpop(NULL)
1756735509949:# ll <- sim$gen_synthpop_demog(design)
1756735509949:#TODO include informative error to check whether exposure table is matching data
1756735509950:sp  <- SynthPop$new(1L, design)
1756736095158:source("./global.R")
1756736208748:design <- Design$new("./inputs/sim_design_docker.yaml")
1756736208773:# RR ----
1756736208773:# Create a named list of Exposure objects for the files in ./inputs/RR
1756736208774:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756736208777:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756736210318:names(RR) <- sapply(RR, function(x) x$get_name())
1756736210320:invisible(future_lapply(RR, function(x) {
1756736210320:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756736210320:},
1756736210320:future.seed = 627524136L))
1756736212694:# # NOTE smooth cannot be exported to Design for now, because the first time
1756736212694:# # this parameter changes we need logic to overwrite unsmoothed files
1756736212694:rm(fl)
1756736212694:#
1756736212695:# # Generate diseases ----
1756736212695:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756736212695:x[["design_"]] <- design
1756736212695:x[["RR"]] <- RR
1756736212695:do.call(Disease$new, x)
1756736212695:})
1756736301720:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756736301721:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756736301721:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756736301721:scenario_suffix_for_pop <- scenario_name
1756736301721:list(
1756736301721:"exposures"          = design_$sim_prm$exposures,
1756736301721:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756736301721:"scenario"           = scenario_name,
1756736301722:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756736301722:"init_year"          = design_$sim_prm$init_year,
1756736301722:"pids"               = "pid",
1756736301722:"years"              = "year",
1756736301722:"ages"               = "age",
1756736301722:"ageL"               = design_$sim_prm$ageL,
1756736301722:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756736301722:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756736301723:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756736301723:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756736301723:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756736301723:)
1756736301723:}
1756736301724:# sim <- SynthPop$new(0L, design)
1756736301724:# sim$write_synthpop(1:500)
1756736301724:# sim$delete_synthpop(NULL)
1756736301724:# ll <- sim$gen_synthpop_demog(design)
1756736301724:#TODO include informative error to check whether exposure table is matching data
1756736301724:sp  <- SynthPop$new(1L, design)
1756736347545:lapply(diseases, function(x) {   # run all the functions on all the diseases
1756736347545:print(x$name)
1756736347545:x$gen_parf(sp, design)$
1756736347545:set_init_prvl(sp, design)$
1756736347546:set_rr(sp, design)$
1756736347546:set_incd_prb(sp, design)$
1756736347546:set_dgns_prb(sp, design)$
1756736347546:set_mrtl_prb(sp, design)
1756736347546:})
1756736386687:transpose(sp$pop[, lapply(.SD, anyNA)], keep.names = "rn")[(V1)] # look for NAs, if NAs, debug
1756736390665:# qsave(sp, "./simulation/tmp.qs")
1756736390665:# sp <- qread("./simulation/tmp.qs")
1756736390665:l <- mk_scenario_init2("", diseases, sp, design)   # define an empty scenario
1756736391737:simcpp(sp$pop, l, sp$mc) # the actual simulation happens here, flips all the coins
1756736413590:View(sp)
1756736417223:View(sp[["pop"]])
1756736922634:par(mfrow=c(2,2))
1756736922767:sp$pop[!is.na(all_cause_mrtl), sum(chd_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "CHD Prev.")]
1756736923090:sp$pop[!is.na(all_cause_mrtl), sum(stroke_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "Stroke Prev.")]
1756736923723:sp$pop[!is.na(all_cause_mrtl), sum(t2dm_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "T2DM Prev.")]
1756736924081:sp$pop[!is.na(all_cause_mrtl), sum(obesity_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "Obesity Prev.")]
1756736953668:sp$update_pop_weights()
1756736955534:sp$pop[, mc := sp$mc_aggr]
1756736955540:par(mfrow=c(2,2))
1756736955540:sp$pop[!is.na(all_cause_mrtl), sum(chd_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "CHD Prev.")]
1756736955641:sp$pop[!is.na(all_cause_mrtl), sum(stroke_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "Stroke Prev.")]
1756736955774:sp$pop[!is.na(all_cause_mrtl), sum(t2dm_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "T2DM Prev.")]
1756736955990:sp$pop[!is.na(all_cause_mrtl), sum(obesity_prvl > 0)/.N, keyby = year][, plot(year, V1, type = "l", ylab = "Obesity Prev.")]
1756737033033:##################################################################################################################
1756737033034:#----------------------------------------------------------------------------------------------------------------#
1756737033034:#-----------------------------------------    Semaglutide Modelling    ------------------------------------------#
1756737033034:#----------------------------------------------------------------------------------------------------------------#
1756737033034:#-----------------------------------    Scenario 1: Individual-level CEA     ------------------------------------#
1756737033035:#----------------------------------------------------------------------------------------------------------------#
1756737033035:##################################################################################################################
1756737033035:scenario_0_fn <- function(sp) {
1756737033036:sp$pop[, c("bmi_delta", "sbp_delta", "tchol_delta") := 0]
1756737033036:}
1756737041898:scenario_1_fn <- function(sp) {
1756737041899:# Set scenario variables #
1756737041899:###########################################################################################################
1756737041899:# Semag scenario variables:
1756737041899:# 1. Baseline year: 2024
1756737041899:# 2. Intervention year: 2025 (years of drug roll-out)
1756737041899:# 3. simulation horizon: 20 years (the end of simulation could be 2043)
1756737041900:# 4. Eligibility criteria: BMI >= 35
1756737041900:# 5. Treatment uptake_rates:
1756737041900:#    a) For CEA: 100 % uptake for the eligible patients at the year of drug roll-out (2025)
1756737041900:#    b) For Budget impact: time-varying
1756737041900:# 6. Efficacy input trajectory (BMI, SBP, total cholesterol) (*uncertainty)
1756737041900:###########################################################################################################
1756737041900:# Efficacy for bmi at 1st year after treatment
1756737041901:tbl <- read_fst("./inputs/other_parameters/bmi_1y_samples.fst", as.data.table = TRUE)
1756737041901:bmi_1y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_1y"])
1756737041901:# Efficacy for bmi at 2nd year after treatment
1756737041901:tbl <- read_fst("./inputs/other_parameters/bmi_2y_samples.fst", as.data.table = TRUE)
1756737041901:bmi_2y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_2y"])
1756737041902:# Efficacy for bmi at 3rd year after treatment
1756737041902:tbl <- read_fst("./inputs/other_parameters/bmi_3y_samples.fst", as.data.table = TRUE)
1756737041902:bmi_3y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_3y"])
1756737041902:# Efficacy for bmi at 4th year after treatment
1756737041902:tbl <- read_fst("./inputs/other_parameters/bmi_4y_samples.fst", as.data.table = TRUE)
1756737041903:bmi_4y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_4y"])
1756737041903:# Efficacy for SBP at 1st year after treatment
1756737041903:tbl <- read_fst("./inputs/other_parameters/sbp_1y_samples.fst", as.data.table = TRUE)
1756737041904:sbp_1y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_1y"])
1756737041904:# Efficacy for SBP at 2nd year of treatment
1756737041904:tbl <- read_fst("./inputs/other_parameters/sbp_2y_samples.fst", as.data.table = TRUE)
1756737041904:sbp_2y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_2y"])
1756737041905:# Efficacy for total cholesterol at 1st year of treatment
1756737041905:tbl <- read_fst("./inputs/other_parameters/tchol_1y_samples.fst", as.data.table = TRUE)
1756737041906:tchol_1y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_1y"])
1756737041907:# Efficacy for total cholesterol at 2nd year of treatment
1756737041907:tbl <- read_fst("./inputs/other_parameters/tchol_2y_samples.fst", as.data.table = TRUE)
1756737041907:tchol_2y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_2y"])
1756737041907:###########################################################################################################
1756737041908:# a variable for how long it has been since the baseline (2024)
1756737041908:baseline_yr <- 24 ## it's 2024, but all years should be relative to year 2000
1756737041908:sp$pop[, ys_rollout := year - baseline_yr] # baseline_yr == 2024 / year == 24 --> baseline year
1756737041908:# a variable for uptake rates based on years after drug roll-out
1756737041909:# * For CEA: 100 % uptake for the eligible patients at the first year of drug roll-out (year == 25 --> rollout year)
1756737041909:# * This uptake rate is independent of individual simulation history, it only depends on years after roll-out
1756737041909:sp$pop[, uptake_rate := ifelse(ys_rollout == 1, 1, 0)] # Set the uptake_rate to be 100% and only possible in year 2025 in CEA
1756737041909:# a variable for defining individual's eligibility for accessing Semaglutide by BMI
1756737041909:sp$pop[, eligible_bi := ifelse(bmi_curr_xps >= 35 & age <= 80, 1, 0)]
1756737041910:# a variable for the uptake of the drug conditioning on meeting eligibility (person_year)
1756737041910:sp$pop[, uptake_psyr := ifelse(eligible_bi ==1, rbinom(.N, size = 1, prob = uptake_rate), 0)]
1756737041910:# a variable for the once-in-a-lifetime uptake during an individual's simulation years
1756737041911:sp$pop[, uptake_one := 0]
1756737041911:sp$pop[uptake_psyr == 1, uptake_one := as.integer(.I == .I[which.min(year)]), by = pid]
1756737041911:### In this testing, only two ids got the treatment: pid 156, 175
1756737041911:# a variable for the year someone uptaking the drug
1756737041912:sp$pop[, anchor_year:=year[uptake_one == 1], by = pid]
1756737041912:# a variable for the year someone enters the synthetic population
1756737041913:sp$pop[, entry_year:= min(year), by = pid]
1756737041913:# a variable for theorectical treatment trajectory
1756737041913:### Step 0: Initialize the column
1756737041913:sp$pop[, trtm_theo := NA_integer_]
1756737041914:### Step 1: Identify first year of treatment uptake
1756737041914:sp$pop[uptake_one == 1, trtm_theo := fifelse(anchor_year > entry_year, 1,0)]
1756737041914:### Step 2: Fill the sequence in subsequent years
1756737041914:sp$pop[, trtm_theo := fifelse(cumsum(!is.na(trtm_theo)) > 0,   # cumsum(): computes a cumulative count of non-NA entries:
1756737041915:# fill in a sequence starting from the first non-NA value
1756737041915:seq_len(.N) - min(which(!is.na(trtm_theo))) + fifelse(anchor_year > entry_year, 1L, 0L),
1756737041915:NA_integer_),
1756737041916:by = pid]
1756737041916:### Step 3: Replace NAs with 0
1756737041916:sp$pop[, trtm_theo := fifelse(is.na(trtm_theo), 0, trtm_theo)]
1756737041917:#scenario_1_fn(sp) # Works!
1756737041917:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year >= 25 & eligible_bi ==1, unique(pid)]]
1756737041917:#test_uptake <- sp$pop[pid %in% sp$pop[uptake_one == 1, unique(pid)]]
1756737041918:########################################################################################
1756737041918:################################          BMI         ##################################
1756737041918:########################################################################################
1756737041919:# a variable for the change in BMI after the uptake of semaglutide
1756737041919:sp$pop[, `:=`(
1756737041919:bmi_delta = fcase(
1756737041919:### All values until year 5, are % weight loss relative to baseline
1756737041920:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1756737041920:trtm_theo == 1, bmi_1y,  ### replace '-0.149' with 'bmi_1y', and link to the uncertainty file: mc + bmi_1y, (Jane today)
1756737041920:### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): 14.9% weight loss
1756737041921:trtm_theo == 2, bmi_2y,  ### replace '-0.152' with 'bmi_2y', and link to the uncertainty file: mc + bmi_2y, (Jane today)
1756737041921:### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): 15.2% weight loss
1756737041921:trtm_theo == 3, bmi_3y,  ### STEP 1 extension: regain 2/3 of weight loss in 1st year treatment cessation
1756737041921:###
1756737041922:trtm_theo == 4, bmi_4y,  ### weight regain at 2nd year treatment cessation (uncertainty?)
1756737041922:trtm_theo >= 5, 0        ### weight return to baseline weight by 3rd year treatment cessation (uncertainty?)
1756737041922:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (bmi_curr_xps)
1756737041923:))
1756737041923:]
1756737041923:# a variable for each individual's baseline weight (baseline: year == 24 / ys_rollout == 0)
1756737041924:# ------------------------------------------ Aug 22, 2025, Jane ------------------------------------------------- #
1756737041924:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1756737041924:# *and, some individuals came in later than year 24, and because they have a chance to uptake drug begining year 25
1756737041924:# *they might already uptake the drug at the first year, which means they won't have a year (anchor-1),
1756737041925:# *so what shall we use as a baseline BMI value here...
1756737041926:sp$pop[, baseline_bmi := {              # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737041926:anchor <- unique(anchor_year)         # So we can distinguish people who have entry at year 24 and who do not
1756737041926:if (is.na(anchor)) {                  # If no anchor is found,
1756737041927:bmi_curr_xps                        # the function simply returns the original bmi_curr_xps as-is
1756737041927:} else {                              # If yes anchor is found
1756737041927:bmi_curr_xps[year == (year[trtm_theo == 1][1] - 1)] # baseline_bmi will take the BMI at the year before trtm_theo==1
1756737041927:}
1756737041928:}, by = pid] #Works!
1756737041928:###############################################################################################################
1756737041928:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1756737041929:###############################################################################################################
1756737041929:sp$pop[, bmi_shift := {             # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737041929:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1756737041929:# return a vector that gets assigned to 'bmi_shift' for the rows in that group
1756737041930:anchor <- unique(anchor_year)     # This line finds a single anchor year (e.g., year 30) for each person.
1756737041930:if (is.na(anchor)) {              # If no anchor is found (to avoid breaking your logic when a person doesn't uptake the drug)
1756737041930:bmi_curr_xps                    # the function simply returns the original bmi_curr_xps as-is
1756737041931:} else {                          # If yes anchor is found, You shift the bmi_curr_xps backward in time (type='lag')
1756737041931:shift(bmi_curr_xps, type = "lag", n = 5) # by 5 years: 5 years is the duration of efficacy inputs (weight loss and reboud)
1756737041931:}
1756737041932:}, by = pid] #Works!
1756737041932:###############################################################################################################
1756737041932:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1756737041932:###############################################################################################################
1756737041933:# a variable for new weight after applying efficacy input during treatment influenced period
1756737041933:sp$pop[, new_bmi := {
1756737041934:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1756737041934:if (is.na(anchor)) {                                      # If no anchor is found,
1756737041934:bmi_curr_xps                                            # the function simply returns the original bmi_curr_xps as-is
1756737041934:} else {                                                  # If yes anchor is found,
1756737041935:fcase(                                                  # We need to assign value to the' new_bmi' based on the time periods
1756737041935:year < anchor,                       bmi_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1756737041935:year >= anchor & year <= anchor + 4, baseline_bmi*(1 + bmi_delta),  # During the 5 years where treatment effects manifest
1756737041936:year > anchor + 4,                   bmi_shift        # After rebound to baseline: revert to the original bmi_curr_xps
1756737041936:)
1756737041936:}
1756737041937:}, by = pid]
1756737041937:#scenario_1_fn(sp) # Works!
1756737041938:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year >= 25 & eligible_bi ==1, unique(pid)]]
1756737041938:#test_uptake <- sp$pop[pid %in% sp$pop[uptake_one == 1, unique(pid)]]
1756737041939:# Overwriting the original bmi exposure column with the newly created bmi column
1756737041939:sp$pop[, bmi_curr_xps := new_bmi]
1756737041939:########################################################################################
1756737041940:################################          SBP         ##################################
1756737041940:########################################################################################
1756737041940:# a variable for the change in SBP after the uptake of semaglutide
1756737041941:sp$pop[, `:=`(
1756737041941:sbp_delta = fcase(
1756737041941:### All values until year 5, are % weight loss relative to baseline
1756737041941:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1756737041942:trtm_theo == 1, sbp_1y,    ### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): mean decrease of 6.2 mmHg from baseline
1756737041942:trtm_theo == 2, sbp_2y,    ### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): mean decrease of 5.7 mmHg from baseline
1756737041942:trtm_theo >= 3, 0        ### STEP 1 extension: assume mean SBP will revert to baseline level after one year without treatment
1756737041943:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (sbp_curr_xps)
1756737041943:))
1756737041943:]
1756737041944:# a variable for each individual's baseline SBP (baseline: year == 24 / ys_rollout == 0)
1756737041944:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1756737041945:sp$pop[, baseline_sbp := {                # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737041945:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1756737041945:if (is.na(anchor)) {                    # If no anchor is found,
1756737041945:sbp_curr_xps                          # the function simply returns the original sbp_curr_xps as-is
1756737041946:} else {                                # If yes anchor is found, baseline_sbp will take the sbp at year 24
1756737041946:sbp_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1756737041946:}
1756737041947:}, by = pid] #Works!
1756737041947:###############################################################################################################
1756737041948:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1756737041948:###############################################################################################################
1756737041948:sp$pop[, sbp_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737041949:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1756737041949:# return a vector that gets assigned to 'sbp_shift' for the rows in that group
1756737041950:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1756737041950:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1756737041950:sbp_curr_xps                       # the function simply returns the original sbp_curr_xps as-is
1756737041951:} else {                             # If yes anchor is found, You shift the sbp_curr_xps backward in time (type='lag')
1756737041951:shift(sbp_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in SBP and rebound)
1756737041951:}
1756737041952:}, by = pid] #Works!
1756737041952:#  A if_else function inside of :={} for creating a new variable
1756737041953:#  if(condition) {
1756737041953:#   what should happen if condition is TRUE
1756737041953:#  } else {
1756737041954:#   what should happen if condition is FALSE
1756737041954:#  }
1756737041955:###############################################################################################################
1756737041955:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1756737041956:###############################################################################################################
1756737041956:# a variable for new weight after applying efficacy input during treatment influenced period
1756737041957:sp$pop[, new_sbp := {
1756737041957:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1756737041957:if (is.na(anchor)) {                                      # If no anchor is found,
1756737041958:sbp_curr_xps                                            # the function simply returns the original sbp_curr_xps as-is
1756737041958:} else {                                                  # If yes anchor is found,
1756737041958:fcase(                                                  # We need to assign value to the 'new_sbp' based on the time periods
1756737041959:year < anchor,                       sbp_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1756737041959:year >= anchor & year <= anchor + 2, baseline_sbp + sbp_delta,  # During the 2 years where treatment effect manifest
1756737041959:year >= anchor + 3,                  sbp_shift        # After sbp rebound to baseline: revert to the original sbp_curr_xps
1756737041960:)
1756737041960:}
1756737041961:}, by = pid]
1756737041961:# Overwriting the original sbp exposure column with the newly created sbp column
1756737041962:sp$pop[, sbp_curr_xps := new_sbp]
1756737041962:########################################################################################
1756737041963:###############################          Tchol         #################################
1756737041963:########################################################################################
1756737041963:# a variable for the change in SBP after the uptake of semaglutide
1756737041964:sp$pop[, `:=`(
1756737041964:tchol_delta = fcase(
1756737041965:trtm_theo == 0, 0,        ### Baseline year, the year patients become eligible
1756737041965:trtm_theo == 1, tchol_1y,    ### 1st year of treatment: ITT effects from STEP 1: mean decrease of 3% from baseline
1756737041965:trtm_theo == 2, tchol_2y,   ### 2nd year of treatment: ITT effects from STEP 5: mean decrease of 3.3% from baseline
1756737041966:trtm_theo >= 3, 0         ### STEP 1 extension: assume mean tchol will revert to baseline level after one year without treatment
1756737041966:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (tchol_curr_xps)
1756737041966:))
1756737041967:]
1756737041968:# a variable for each individual's baseline Tchol (baseline: year == 24 / ys_rollout == 0)
1756737041968:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1756737041968:sp$pop[, baseline_tchol := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737041969:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1756737041969:if (is.na(anchor)) {                    # If no anchor is found,
1756737041970:tchol_curr_xps                        # the function simply returns the original tchol_curr_xps as-is
1756737041970:} else {                                # If yes anchor is found, baseline_tchol will take the tchol at year 24
1756737041970:tchol_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1756737041971:}
1756737041971:}, by = pid] #Works!
1756737041972:###############################################################################################################
1756737041973:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1756737041973:###############################################################################################################
1756737041974:sp$pop[, tchol_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737041974:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1756737041975:# return a vector that gets assigned to 'tchol_shift' for the rows in that group
1756737041975:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1756737041976:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1756737041977:tchol_curr_xps                       # the function simply returns the original tchol_curr_xps as-is
1756737041977:} else {                             # If yes anchor is found, You shift the tchol_curr_xps backward in time (type='lag')
1756737041977:shift(tchol_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in tchol and reboud)
1756737041978:}
1756737041978:}, by = pid] #Works!
1756737041979:# test <- sp$pop[pid %in% c(156, 175)]
1756737041979:###############################################################################################################
1756737041980:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1756737041980:###############################################################################################################
1756737041981:# a variable for new weight after applying efficacy input during treatment influenced period
1756737041981:sp$pop[, new_tchol := {
1756737041982:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1756737041982:if (is.na(anchor)) {                                      # If no anchor is found,
1756737041983:tchol_curr_xps                                          # the function simply returns the original tchol_curr_xps as-is
1756737041983:} else {                                                  # If yes anchor is found,
1756737041984:fcase(                                                  # We need to assign value to the 'new_tchol' based on the time periods
1756737041984:year < anchor,                       tchol_curr_xps,  # Before anchor year/uptake: original values (including baseline year)
1756737041984:year >= anchor & year <= anchor + 2, baseline_tchol*(1 + tchol_delta),  # During the 2 years where treatment effect manifest
1756737041985:year >= anchor + 3,                  tchol_shift      # After tchol rebound to baseline: revert to the original tchol_curr_xps
1756737041985:)
1756737041986:}
1756737041986:}, by = pid]
1756737041987:# Overwriting the original tchol exposure column with the newly created tchol column
1756737041988:sp$pop[, tchol_curr_xps := new_tchol]
1756737041988:### Jane Aug 2025, test scenario on sp$pop --> Looks like until here everything worked!!!
1756737041989:##################### Get rid of unnecessary variables ##########################
1756737041990:# Delete unnecessary variables from synthpop #
1756737041990:sp$pop[, c("rankstat_sbp", "rankstat_tchol", "ys_rollout", "uptake_rate",
1756737041990:"eligible_bi", "uptake_psyr", "uptake_one", "anchor_year",
1756737041991:"entry_year", "trtm_theo", "baseline_bmi", "bmi_shift", "new_bmi",
1756737041991:"baseline_sbp", "sbp_shift", "new_sbp", "baseline_tchol",
1756737041992:"tchol_shift", "new_tchol") := NULL]
1756737041993:}
1756737041994:# Good to get rid of all the intermediate variables,which were created to get to the new exposure column (tchol_curr_xps)
1756737041994:# The model runs faster without them
1756737041994:# Keep the variables needed for further analysis
1756737041994:#scenario_1_fn(sp) # Works!
1756737041994:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year >= 25 & eligible_bi ==1, unique(pid)]]
1756737041995:#test_uptake <- sp$pop[pid %in% sp$pop[uptake_one == 1, unique(pid)]]
1756737041995:##################################################################################################################
1756737041995:#----------------------------------------------------------------------------------------------------------------#
1756737041995:#-----------------------------------------    Semaglutide Modelling    ------------------------------------------#
1756737041995:#----------------------------------------------------------------------------------------------------------------#
1756737041995:#-----------------------------------------   Scenario 2: Budget impact     --------------------------------------#
1756737041995:#----------------------------------------------------------------------------------------------------------------#
1756737041995:##################################################################################################################
1756737041995:##################################################################################################################
1756737041996:####                                                                                                          ####
1756737041996:####           2. Budget impact scenario:                                                                     ####
1756737041996:####              - Open cohort. Baseline year: 2024, Drug roll-out year: 2025                                ####
1756737041996:####              - Uptake possible at any time point after roll-out                                          ####
1756737041996:####              - Eligibility criteria: BMI >= 35 (eligible_bi), assessed at each year                      ####
1756737041996:####              ############################################################################                ####
1756737041996:####              ** Time-varying uptake rates (by Year after roll-out):                                      ####
1756737041996:####                   Year 1-2 (2025-2026): 20%  - Moderate uptake for early adopters                        ####
1756737041996:####                   Year 3-5 (2027-2029): 40%  - Higher uptake as awareness increases                      ####
1756737041996:####                   Year >5  (>2030)    : 60%  - Potential plateau                                         ####
1756737041997:####              ** ??? This could be problematic, because:                                                  ####
1756737041997:####              ** !!! The overall prevalence in the population over a time period is different from        ####
1756737041997:####              ** !!! the probability of individual uptake each year (incidence)                           ####
1756737041997:####              ############################################################################                ####
1756737041997:####              Assumptions on the time-varying uptake rate:                                                ####
1756737041997:####              1) After 10 year, ~overall prevalence of uptake: 50-60%                                     ####
1756737041997:####              2) We will assume a 10% uptake rate every year                                              ####
1756737041997:####                 * This gives us a 58% overall uptake prevalence over 10 years, 75% over 20 ys            ####
1756737041997:####                 * This gives us a curve of declining numbers of people uptaking the drug over years      ####
1756737041997:####              ############################################################################                ####
1756737041997:####              - People can only uptake the treatment *once* during lifetime                               ####
1756737041998:####              - Treatment last for 2 years (ITT effect, no discontinuation applied to individuals)        ####
1756737041998:####              - Efficacy trajectory (weight loss--rebound--natural progression) applied identical for     ####
1756737041998:####                all eligible patients                                                                     ####
1756737041998:####              - Follow-up period: 5, 10, 20 year                                                          ####
1756737041998:####                                                                                                          ####
1756737041998:##################################################################################################################
1756737041998:##################################################################################################################
1756737041998:#### What do we need as input/function arguments in this scenario: ### Jane Aug 11
1756737041998:#### 1. lifecourse dataset, with original BMI, SBP, Cholesterol
1756737041998:####    Semag:    sppop, bmi_curr_xps, sbp_curr_xps, tchol_curr_xps
1756737041998:####
1756737041999:#### 2. Time horizon: initial year, intervention year, simulation horizon
1756737041999:####    Semag:    2013-2043, with 2024 as baseline year
1756737041999:####
1756737041999:#### 3. Policy input: Eligibility and uptake of treatment
1756737041999:####    Semag:    ys_rollout, eligible_bi, uptake_rate
1756737041999:####
1756737041999:#### 4. Efficacy input: change in BMI, SBP, Cholesterol from RCT
1756737041999:####    Semag:    efficacy input trajectory
1756737041999:####                  Treatment_y1,  xyz,     ### 1st year of treatment: ITT effects from RCT
1756737041999:####                  Treatment_y2,  xyz,     ### 2nd year of treatment: ITT effects from RCT
1756737042000:####                  Treatment_y3,  xyz,     ### Results from STEP 1 extension: waning of 2-year treatment effect
1756737042000:####                  ### The efficacy should be assigned until here, the rest we will revert to the original exposure column
1756737042000:####                  ******
1756737042000:####                  Uncertainty: consistent among estimates (with CI) from multiple RCTs,
1756737042000:####                               In each iteration, sample values from uniform distribution, and use these values
1756737042000:####                               as quantile [0. 1] to sample values from distributions of efficacy inputs
1756737042000:####                               ---> individual fixed effect (?)
1756737042000:####                  Draw random values from uniform distribution for as many MCs
1756737042000:####                  There will be one dataset / input file (?) for efficacy inputs,
1756737042000:####                  ---> In this dataset, each columns is for one efficacy inputs (for all exposures)
1756737042001:####                  One column for mc (1-1000): Col_MC  Col_Quant  Col_BMI_Y1 Col_BMI_Y2 Col_SBP_Y2 (?)
1756737042001:####                  ******
1756737042001:####
1756737042001:#### 5. lifecourse dataset, with modified exposure variables (replacing the original ones)
1756737042001:####    Semag:    bmi_curr_xps := new_bmi
1756737042001:##################################################################################################################
1756737042001:### Scenario 2 - Budget impact of semaglutide 2.4 mg for weight management in German adult population
1756737042001:scenario_2_fn <- function(sp) {
1756737042002:# Efficacy for bmi at 1st year after treatment
1756737042002:tbl <- read_fst("./inputs/other_parameters/bmi_1y_samples.fst", as.data.table = TRUE)
1756737042002:bmi_1y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_1y"])
1756737042002:# Efficacy for bmi at 2nd year after treatment
1756737042002:tbl <- read_fst("./inputs/other_parameters/bmi_2y_samples.fst", as.data.table = TRUE)
1756737042002:bmi_2y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_2y"])
1756737042003:# Efficacy for bmi at 3rd year after treatment
1756737042003:tbl <- read_fst("./inputs/other_parameters/bmi_3y_samples.fst", as.data.table = TRUE)
1756737042003:bmi_3y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_3y"])
1756737042003:# Efficacy for bmi at 4th year after treatment
1756737042003:tbl <- read_fst("./inputs/other_parameters/bmi_4y_samples.fst", as.data.table = TRUE)
1756737042003:bmi_4y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_4y"])
1756737042004:# Efficacy for SBP at 1st year after treatment
1756737042004:tbl <- read_fst("./inputs/other_parameters/sbp_1y_samples.fst", as.data.table = TRUE)
1756737042004:sbp_1y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_1y"])
1756737042004:# Efficacy for SBP at 2nd year of treatment
1756737042004:tbl <- read_fst("./inputs/other_parameters/sbp_2y_samples.fst", as.data.table = TRUE)
1756737042005:sbp_2y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_2y"])
1756737042005:# Efficacy for total cholesterol at 1st year of treatment
1756737042005:tbl <- read_fst("./inputs/other_parameters/tchol_1y_samples.fst", as.data.table = TRUE)
1756737042005:tchol_1y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_1y"])
1756737042005:# Efficacy for total cholesterol at 2nd year of treatment
1756737042006:tbl <- read_fst("./inputs/other_parameters/tchol_2y_samples.fst", as.data.table = TRUE)
1756737042006:tchol_2y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_2y"])
1756737042006:###########################################################################################################
1756737042006:# a variable for how long it has been since the baseline (2024)
1756737042006:baseline_yr <- 24 ## it's 2024, but all years should be relative to year 2000
1756737042006:sp$pop[, ys_rollout := year - baseline_yr] # baseline_yr == 2024 / year == 24 --> baseline year
1756737042007:# a variable for uptake rates based on years after drug roll-out
1756737042007:# * For Budget impact, We assume a 10% uptake rate every year
1756737042008:# * This uptake rate is independent of individual simulation history, it only depends on years after roll-out
1756737042008:sp$pop[, uptake_rate := ifelse(ys_rollout >= 1, 0.1, 0)]
1756737042008:# a variable for defining individual's eligibility for accessing Semaglutide by BMI
1756737042009:sp$pop[, eligible_bi := ifelse(bmi_curr_xps >= 35, 1, 0)]
1756737042009:# a variable for the uptake of the drug conditioning on meeting eligibility (person_year)
1756737042009:sp$pop[, uptake_psyr := ifelse(eligible_bi ==1, rbinom(.N, size = 1, prob = uptake_rate), 0)]
1756737042009:# a variable for the once-in-a-lifetime uptake during an individual's simulation years
1756737042010:sp$pop[, uptake_one := 0]
1756737042010:sp$pop[uptake_psyr == 1, uptake_one := as.integer(.I == .I[which.min(year)]), by = pid]
1756737042010:### In this testing, only two ids got the treatment: pid 156, 175
1756737042010:# a variable for the year someone uptaking the drug
1756737042010:sp$pop[, anchor_year:=year[uptake_one == 1], by = pid]
1756737042011:# a variable for the year someone enters the synthetic population
1756737042011:sp$pop[, entry_year:= min(year), by = pid]
1756737042011:# a variable for theorectical treatment trajectory
1756737042011:### Step 0: Initialize the column
1756737042012:sp$pop[, trtm_theo := NA_integer_]
1756737042012:### Step 1: Identify first year of treatment uptake
1756737042012:sp$pop[uptake_one == 1, trtm_theo := fifelse(anchor_year > entry_year, 1,0)]
1756737042012:### Step 2: Fill the sequence in subsequent years
1756737042012:sp$pop[, trtm_theo := fifelse(cumsum(!is.na(trtm_theo)) > 0,   # cumsum(): computes a cumulative count of non-NA entries:
1756737042013:# fill in a sequence starting from the first non-NA value
1756737042013:seq_len(.N) - min(which(!is.na(trtm_theo))) + fifelse(anchor_year > entry_year, 1L, 0L),
1756737042013:NA_integer_),
1756737042013:by = pid]
1756737042013:### Step 3: Replace NAs with 0
1756737042014:sp$pop[, trtm_theo := fifelse(is.na(trtm_theo), 0, trtm_theo)]
1756737042014:########################################################################################
1756737042014:################################          BMI         ##################################
1756737042014:########################################################################################
1756737042015:# a variable for the change in BMI after the uptake of semaglutide
1756737042015:sp$pop[, `:=`(
1756737042015:bmi_delta = fcase(
1756737042015:### All values until year 5, are % weight loss relative to baseline
1756737042016:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1756737042016:trtm_theo == 1, bmi_1y,  ### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): 14.9% weight loss (uncertainty?)
1756737042016:trtm_theo == 2, bmi_2y,  ### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): 15.2% weight loss (uncertainty?)
1756737042016:trtm_theo == 3, bmi_3y,  ### STEP 1 extension: regain 2/3 of weight loss in 1st year treatment cessation (uncertainty?)
1756737042016:trtm_theo == 4, bmi_4y,  ### weight regain at 2nd year treatment cessation (uncertainty?)
1756737042017:trtm_theo >= 5, 0        ### weight return to baseline weight by 3rd year treatment cessation (uncertainty?)
1756737042017:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (bmi_curr_xps)
1756737042017:))
1756737042017:]
1756737042018:# a variable for each individual's baseline weight (baseline: year == 24 / ys_rollout == 0)
1756737042018:# ------------------------------------------ Aug 22, 2025, Jane ------------------------------------------------- #
1756737042018:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1756737042018:# *and, some individuals came in later than year 24, and because they have a chance to uptake drug begining year 25
1756737042019:# *they might already uptake the drug at the first year, which means they won't have a year (anchor-1),
1756737042019:# *so what shall we use as a baseline BMI value here...
1756737042019:sp$pop[, baseline_bmi := {              # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737042019:anchor <- unique(anchor_year)         # So we can distinguish people who have entry at year 24 and who do not
1756737042020:if (is.na(anchor)) {                  # If no anchor is found,
1756737042020:bmi_curr_xps                        # the function simply returns the original bmi_curr_xps as-is
1756737042020:} else {                              # If yes anchor is found
1756737042020:bmi_curr_xps[year == (year[trtm_theo == 1][1] - 1)] # baseline_bmi will take the BMI at the year before trtm_theo==1
1756737042021:}
1756737042021:}, by = pid] #Works!
1756737042021:###############################################################################################################
1756737042022:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1756737042022:###############################################################################################################
1756737042022:sp$pop[, bmi_shift := {             # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737042022:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1756737042023:# return a vector that gets assigned to 'bmi_shift' for the rows in that group
1756737042023:anchor <- unique(anchor_year)     # This line finds a single anchor year (e.g., year 30) for each person.
1756737042023:if (is.na(anchor)) {              # If no anchor is found (to avoid breaking your logic when a person doesn't uptake the drug)
1756737042023:bmi_curr_xps                    # the function simply returns the original bmi_curr_xps as-is
1756737042024:} else {                          # If yes anchor is found, You shift the bmi_curr_xps backward in time (type='lag')
1756737042024:shift(bmi_curr_xps, type = "lag", n = 5) # by 5 years: 5 years is the duration of efficacy inputs (weight loss and reboud)
1756737042024:}
1756737042024:}, by = pid] #Works!
1756737042025:###############################################################################################################
1756737042025:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1756737042025:###############################################################################################################
1756737042026:# a variable for new weight after applying efficacy input during treatment influenced period
1756737042026:sp$pop[, new_bmi := {
1756737042026:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1756737042026:if (is.na(anchor)) {                                      # If no anchor is found,
1756737042027:bmi_curr_xps                                            # the function simply returns the original bmi_curr_xps as-is
1756737042027:} else {                                                  # If yes anchor is found,
1756737042027:fcase(                                                  # We need to assign value to the' new_bmi' based on the time periods
1756737042028:year < anchor,                       bmi_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1756737042028:year >= anchor & year <= anchor + 4, baseline_bmi*(1 + bmi_delta),  # During the 5 years where treatment effects manifest
1756737042028:year > anchor + 4,                   bmi_shift        # After rebound to baseline: revert to the original bmi_curr_xps
1756737042028:)
1756737042029:}
1756737042029:}, by = pid]
1756737042030:# Overwriting the original bmi exposure column with the newly created bmi column
1756737042030:sp$pop[, bmi_curr_xps := new_bmi]
1756737042030:########################################################################################
1756737042031:################################          SBP         ##################################
1756737042031:########################################################################################
1756737042031:# a variable for the change in SBP after the uptake of semaglutide
1756737042031:sp$pop[, `:=`(
1756737042032:sbp_delta = fcase(
1756737042033:### All values until year 5, are % weight loss relative to baseline
1756737042033:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1756737042033:trtm_theo == 1, sbp_1y,    ### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): mean decrease of 6.2 mmHg from baseline
1756737042033:trtm_theo == 2, sbp_2y,    ### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): mean decrease of 5.7 mmHg from baseline
1756737042034:trtm_theo >= 3, 0        ### STEP 1 extension: assume mean SBP will revert to baseline level after one year without treatment
1756737042034:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (sbp_curr_xps)
1756737042034:))
1756737042035:]
1756737042035:# a variable for each individual's baseline SBP (baseline: year == 24 / ys_rollout == 0)
1756737042035:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1756737042036:sp$pop[, baseline_sbp := {                # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737042037:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1756737042037:if (is.na(anchor)) {                    # If no anchor is found,
1756737042037:sbp_curr_xps                          # the function simply returns the original sbp_curr_xps as-is
1756737042038:} else {                                # If yes anchor is found, baseline_sbp will take the sbp at year 24
1756737042038:sbp_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1756737042038:}
1756737042039:}, by = pid] #Works!
1756737042039:###############################################################################################################
1756737042040:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1756737042040:###############################################################################################################
1756737042040:sp$pop[, sbp_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737042041:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1756737042041:# return a vector that gets assigned to 'sbp_shift' for the rows in that group
1756737042041:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1756737042042:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1756737042042:sbp_curr_xps                       # the function simply returns the original sbp_curr_xps as-is
1756737042042:} else {                             # If yes anchor is found, You shift the sbp_curr_xps backward in time (type='lag')
1756737042043:shift(sbp_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in SBP and rebound)
1756737042043:}
1756737042043:}, by = pid] #Works!
1756737042044:#  A if_else function inside of :={} for creating a new variable
1756737042044:#  if(condition) {
1756737042045:#   what should happen if condition is TRUE
1756737042045:#  } else {
1756737042045:#   what should happen if condition is FALSE
1756737042046:#  }
1756737042046:###############################################################################################################
1756737042046:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1756737042047:###############################################################################################################
1756737042047:# a variable for new weight after applying efficacy input during treatment influenced period
1756737042048:sp$pop[, new_sbp := {
1756737042048:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1756737042048:if (is.na(anchor)) {                                      # If no anchor is found,
1756737042049:sbp_curr_xps                                            # the function simply returns the original sbp_curr_xps as-is
1756737042049:} else {                                                  # If yes anchor is found,
1756737042049:fcase(                                                  # We need to assign value to the 'new_sbp' based on the time periods
1756737042050:year < anchor,                       sbp_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1756737042050:year >= anchor & year <= anchor + 2, baseline_sbp + sbp_delta,  # During the 2 years where treatment effect manifest
1756737042050:year >= anchor + 3,                  sbp_shift        # After sbp rebound to baseline: revert to the original sbp_curr_xps
1756737042051:)
1756737042051:}
1756737042051:}, by = pid]
1756737042052:# Overwriting the original sbp exposure column with the newly created sbp column
1756737042052:sp$pop[, sbp_curr_xps := new_sbp]
1756737042053:########################################################################################
1756737042054:###############################          Tchol         #################################
1756737042054:########################################################################################
1756737042054:# a variable for the change in SBP after the uptake of semaglutide
1756737042055:sp$pop[, `:=`(
1756737042055:tchol_delta = fcase(
1756737042056:trtm_theo == 0, 0,        ### Baseline year, the year patients become eligible
1756737042056:trtm_theo == 1, tchol_1y,    ### 1st year of treatment: ITT effects from STEP 1: mean decrease of 3% from baseline
1756737042056:trtm_theo == 2, tchol_2y,   ### 2nd year of treatment: ITT effects from STEP 5: mean decrease of 3.3% from baseline
1756737042057:trtm_theo >= 3, 0         ### STEP 1 extension: assume mean tchol will revert to baseline level after one year without treatment
1756737042057:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (tchol_curr_xps)
1756737042058:))
1756737042058:]
1756737042059:# a variable for each individual's baseline Tchol (baseline: year == 24 / ys_rollout == 0)
1756737042059:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1756737042059:sp$pop[, baseline_tchol := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737042060:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1756737042060:if (is.na(anchor)) {                    # If no anchor is found,
1756737042060:tchol_curr_xps                        # the function simply returns the original tchol_curr_xps as-is
1756737042061:} else {                                # If yes anchor is found, baseline_tchol will take the tchol at year 24
1756737042061:tchol_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1756737042062:}
1756737042062:}, by = pid] #Works!
1756737042063:###############################################################################################################
1756737042063:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1756737042063:###############################################################################################################
1756737042064:sp$pop[, tchol_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1756737042064:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1756737042065:# return a vector that gets assigned to 'tchol_shift' for the rows in that group
1756737042065:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1756737042066:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1756737042066:tchol_curr_xps                       # the function simply returns the original tchol_curr_xps as-is
1756737042066:} else {                             # If yes anchor is found, You shift the tchol_curr_xps backward in time (type='lag')
1756737042067:shift(tchol_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in tchol and reboud)
1756737042067:}
1756737042068:}, by = pid] #Works!
1756737042068:# test <- sp$pop[pid %in% c(156, 175)]
1756737042069:###############################################################################################################
1756737042069:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1756737042069:###############################################################################################################
1756737042070:# a variable for new weight after applying efficacy input during treatment influenced period
1756737042071:sp$pop[, new_tchol := {
1756737042071:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1756737042071:if (is.na(anchor)) {                                      # If no anchor is found,
1756737042072:tchol_curr_xps                                          # the function simply returns the original tchol_curr_xps as-is
1756737042072:} else {                                                  # If yes anchor is found,
1756737042073:fcase(                                                  # We need to assign value to the 'new_tchol' based on the time periods
1756737042073:year < anchor,                       tchol_curr_xps,  # Before anchor year/uptake: original values (including baseline year)
1756737042073:year >= anchor & year <= anchor + 2, baseline_tchol*(1 + tchol_delta),  # During the 2 years where treatment effect manifest
1756737042074:year >= anchor + 3,                  tchol_shift      # After tchol rebound to baseline: revert to the original tchol_curr_xps
1756737042074:)
1756737042075:}
1756737042075:}, by = pid]
1756737042076:# Overwriting the original tchol exposure column with the newly created tchol column
1756737042076:sp$pop[, tchol_curr_xps := new_tchol]
1756737042077:### Jane Aug 2025, test scenario on sp$pop --> Looks like until here everything worked!!!
1756737042078:##################### Get rid of unnecessary variables ##########################
1756737042078:# Delete unnecessary variables from synthpop #
1756737042078:sp$pop[, c("rankstat_sbp", "rankstat_tchol", "ys_rollout", "uptake_rate",
1756737042079:"eligible_bi", "uptake_psyr", "uptake_one", "anchor_year",
1756737042079:"entry_year", "trtm_theo", "baseline_bmi", "bmi_shift", "new_bmi",
1756737042080:"baseline_sbp", "sbp_shift", "new_sbp", "baseline_tchol",
1756737042080:"tchol_shift", "new_tchol") := NULL]
1756737042081:}
1756737062163:source("./global.R")
1756737148855:# Load scenario and sensitivity analyses functions
1756737148856:source("./auxil/scenarios_GLP_uncertain.R")
1756737181091:# Initiate .Random.seed for safety
1756737181091:runif(1)
1756737183912:# New runs?
1756737183912:new_runs <- TRUE
1756737184625:new_export <- TRUE
1756737187867:if(new_runs){
1756737187868:# Create batches for batched simulation
1756737187868:batch_size <- 10
1756737187868:iterations <- 200
1756737187869:first_iteration <- 1
1756737187869:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1756737187869:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1756737187869:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1756737187870:}
1756737204318:analysis_name <- "GLP_Test"
1756737204318:IMPACTncd <- Simulation$new("./inputs/sim_design.yaml", analysis_name)
1756737302776:if(new_runs){
1756737302776:for(i in batches){
1756737302776:scenario_fn <- scenario_0_fn
1756737302777:IMPACTncd$
1756737302777:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1756737302777:scenario_fn <- scenario_1_fn
1756737302777:IMPACTncd$
1756737302778:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1756737302778:# scenario_fn <- scenario_2_fn
1756737302778:#
1756737302778:# IMPACTncd$
1756737302778:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1756737302779:#
1756737302779:# scenario_fn <- scenario_3_fn
1756737302779:#
1756737302779:# IMPACTncd$
1756737302779:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1756737302779:#
1756737302780:# scenario_fn <- scenario_4_fn
1756737302780:#
1756737302780:# IMPACTncd$
1756737302780:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1756737302780:}
1756737302781:}
1756737690022:source("./global.R")
1756737773177:design <- Design$new("./inputs/sim_design_docker.yaml")
1756737773214:# RR ----
1756737773214:# Create a named list of Exposure objects for the files in ./inputs/RR
1756737773214:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756737773218:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756737775449:names(RR) <- sapply(RR, function(x) x$get_name())
1756737775453:invisible(future_lapply(RR, function(x) {
1756737775453:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756737775453:},
1756737775453:future.seed = 627524136L))
1756737778710:# # NOTE smooth cannot be exported to Design for now, because the first time
1756737778711:# # this parameter changes we need logic to overwrite unsmoothed files
1756737778711:rm(fl)
1756737778711:#
1756737778712:# # Generate diseases ----
1756737778712:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756737778712:x[["design_"]] <- design
1756737778712:x[["RR"]] <- RR
1756737778713:do.call(Disease$new, x)
1756737778713:})
1756737867428:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756737867428:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756737867428:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756737867429:scenario_suffix_for_pop <- scenario_name
1756737867429:list(
1756737867429:"exposures"          = design_$sim_prm$exposures,
1756737867429:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756737867429:"scenario"           = scenario_name,
1756737867429:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756737867429:"init_year"          = design_$sim_prm$init_year,
1756737867430:"pids"               = "pid",
1756737867430:"years"              = "year",
1756737867430:"ages"               = "age",
1756737867430:"ageL"               = design_$sim_prm$ageL,
1756737867430:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756737867431:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756737867431:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756737867431:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756737867431:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756737867431:)
1756737867432:}
1756737867432:# sim <- SynthPop$new(0L, design)
1756737867432:# sim$write_synthpop(1:500)
1756737867433:# sim$delete_synthpop(NULL)
1756737867433:# ll <- sim$gen_synthpop_demog(design)
1756737867433:#TODO include informative error to check whether exposure table is matching data
1756737867433:sp  <- SynthPop$new(1L, design)
1756737885483:lapply(diseases, function(x) {   # run all the functions on all the diseases
1756737885483:print(x$name)
1756737885483:x$gen_parf(sp, design)$
1756737885484:set_init_prvl(sp, design)$
1756737885484:set_rr(sp, design)$
1756737885484:set_incd_prb(sp, design)$
1756737885484:set_dgns_prb(sp, design)$
1756737885485:set_mrtl_prb(sp, design)
1756737885485:})
1756738316354:transpose(sp$pop[, lapply(.SD, anyNA)], keep.names = "rn")[(V1)] # look for NAs, if NAs, debug
1756738334519:# qsave(sp, "./simulation/tmp.qs")
1756738334519:# sp <- qread("./simulation/tmp.qs")
1756738334519:l <- mk_scenario_init2("", diseases, sp, design)   # define an empty scenario
1756738335469:simcpp(sp$pop, l, sp$mc) # the actual simulation happens here, flips all the coins
1756738551934:source("./global.R")
1756738630076:design <- Design$new("./inputs/sim_design_docker.yaml")
1756738630097:# RR ----
1756738630097:# Create a named list of Exposure objects for the files in ./inputs/RR
1756738630097:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756738630102:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756738631808:names(RR) <- sapply(RR, function(x) x$get_name())
1756738631811:invisible(future_lapply(RR, function(x) {
1756738631812:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756738631812:},
1756738631812:future.seed = 627524136L))
1756738634323:# # NOTE smooth cannot be exported to Design for now, because the first time
1756738634323:# # this parameter changes we need logic to overwrite unsmoothed files
1756738634323:rm(fl)
1756738634323:#
1756738634324:# # Generate diseases ----
1756738634324:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756738634324:x[["design_"]] <- design
1756738634324:x[["RR"]] <- RR
1756738634324:do.call(Disease$new, x)
1756738634325:})
1756738697489:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756738697489:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756738697489:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756738697489:scenario_suffix_for_pop <- scenario_name
1756738697489:list(
1756738697490:"exposures"          = design_$sim_prm$exposures,
1756738697490:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756738697490:"scenario"           = scenario_name,
1756738697490:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756738697490:"init_year"          = design_$sim_prm$init_year,
1756738697490:"pids"               = "pid",
1756738697491:"years"              = "year",
1756738697491:"ages"               = "age",
1756738697491:"ageL"               = design_$sim_prm$ageL,
1756738697491:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756738697491:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756738697492:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756738697492:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756738697492:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756738697492:)
1756738697493:}
1756738697493:# sim <- SynthPop$new(0L, design)
1756738697493:# sim$write_synthpop(1:500)
1756738697493:# sim$delete_synthpop(NULL)
1756738697494:# ll <- sim$gen_synthpop_demog(design)
1756738697494:#TODO include informative error to check whether exposure table is matching data
1756738697494:sp  <- SynthPop$new(1L, design)
1756738953730:source("./global.R")
1756739056171:design <- Design$new("./inputs/sim_design_docker.yaml")
1756739056192:# RR ----
1756739056193:# Create a named list of Exposure objects for the files in ./inputs/RR
1756739056193:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756739056197:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756739057615:names(RR) <- sapply(RR, function(x) x$get_name())
1756739057618:invisible(future_lapply(RR, function(x) {
1756739057618:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756739057618:},
1756739057618:future.seed = 627524136L))
1756739060599:# # NOTE smooth cannot be exported to Design for now, because the first time
1756739060600:# # this parameter changes we need logic to overwrite unsmoothed files
1756739060600:rm(fl)
1756739060600:#
1756739060600:# # Generate diseases ----
1756739060600:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756739060601:x[["design_"]] <- design
1756739060601:x[["RR"]] <- RR
1756739060601:do.call(Disease$new, x)
1756739060601:})
1756739156252:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756739156252:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756739156252:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756739156253:scenario_suffix_for_pop <- scenario_name
1756739156253:list(
1756739156253:"exposures"          = design_$sim_prm$exposures,
1756739156253:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756739156253:"scenario"           = scenario_name,
1756739156253:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756739156253:"init_year"          = design_$sim_prm$init_year,
1756739156253:"pids"               = "pid",
1756739156254:"years"              = "year",
1756739156254:"ages"               = "age",
1756739156254:"ageL"               = design_$sim_prm$ageL,
1756739156254:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756739156254:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756739156254:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756739156255:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756739156255:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756739156255:)
1756739156255:}
1756739156256:# sim <- SynthPop$new(0L, design)
1756739156256:# sim$write_synthpop(1:500)
1756739156256:# sim$delete_synthpop(NULL)
1756739156256:# ll <- sim$gen_synthpop_demog(design)
1756739156256:#TODO include informative error to check whether exposure table is matching data
1756739156256:sp  <- SynthPop$new(1L, design)
1756739252304:5000*0.05
1756739266355:source("./global.R")
1756739352072:design <- Design$new("./inputs/sim_design_docker.yaml")
1756739352090:# RR ----
1756739352090:# Create a named list of Exposure objects for the files in ./inputs/RR
1756739352090:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756739352093:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756739353410:names(RR) <- sapply(RR, function(x) x$get_name())
1756739353413:invisible(future_lapply(RR, function(x) {
1756739353413:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756739353413:},
1756739353413:future.seed = 627524136L))
1756739355768:# # NOTE smooth cannot be exported to Design for now, because the first time
1756739355769:# # this parameter changes we need logic to overwrite unsmoothed files
1756739355769:rm(fl)
1756739355769:#
1756739355770:# # Generate diseases ----
1756739355770:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756739355770:x[["design_"]] <- design
1756739355771:x[["RR"]] <- RR
1756739355771:do.call(Disease$new, x)
1756739355771:})
1756739417122:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756739417122:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756739417122:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756739417123:scenario_suffix_for_pop <- scenario_name
1756739417123:list(
1756739417123:"exposures"          = design_$sim_prm$exposures,
1756739417123:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756739417123:"scenario"           = scenario_name,
1756739417123:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756739417124:"init_year"          = design_$sim_prm$init_year,
1756739417124:"pids"               = "pid",
1756739417124:"years"              = "year",
1756739417124:"ages"               = "age",
1756739417124:"ageL"               = design_$sim_prm$ageL,
1756739417124:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756739417125:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756739417125:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756739417125:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756739417125:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756739417126:)
1756739417126:}
1756739417126:# sim <- SynthPop$new(0L, design)
1756739417127:# sim$write_synthpop(1:500)
1756739417127:# sim$delete_synthpop(NULL)
1756739417127:# ll <- sim$gen_synthpop_demog(design)
1756739417127:#TODO include informative error to check whether exposure table is matching data
1756739417127:sp  <- SynthPop$new(1L, design)
1756739452572:View(sp)
1756739459413:View(sp[["pop"]])
1756739509251:source("./global.R")
1756739609415:design <- Design$new("./inputs/sim_design_docker.yaml")
1756739609440:# RR ----
1756739609440:# Create a named list of Exposure objects for the files in ./inputs/RR
1756739609440:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756739609444:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756739611716:names(RR) <- sapply(RR, function(x) x$get_name())
1756739611719:invisible(future_lapply(RR, function(x) {
1756739611719:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756739611720:},
1756739611720:future.seed = 627524136L))
1756739614746:# # NOTE smooth cannot be exported to Design for now, because the first time
1756739614746:# # this parameter changes we need logic to overwrite unsmoothed files
1756739614746:rm(fl)
1756739614747:#
1756739614747:# # Generate diseases ----
1756739614747:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756739614747:x[["design_"]] <- design
1756739614747:x[["RR"]] <- RR
1756739614748:do.call(Disease$new, x)
1756739614748:})
1756739737064:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756739737065:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756739737066:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756739737066:scenario_suffix_for_pop <- scenario_name
1756739737066:list(
1756739737067:"exposures"          = design_$sim_prm$exposures,
1756739737067:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756739737068:"scenario"           = scenario_name,
1756739737068:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756739737069:"init_year"          = design_$sim_prm$init_year,
1756739737069:"pids"               = "pid",
1756739737070:"years"              = "year",
1756739737070:"ages"               = "age",
1756739737070:"ageL"               = design_$sim_prm$ageL,
1756739737071:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756739737071:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756739737071:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756739737072:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756739737072:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756739737073:)
1756739737073:}
1756739737074:# sim <- SynthPop$new(0L, design)
1756739737074:# sim$write_synthpop(1:500)
1756739737074:# sim$delete_synthpop(NULL)
1756739737075:# ll <- sim$gen_synthpop_demog(design)
1756739737075:#TODO include informative error to check whether exposure table is matching data
1756739737075:sp  <- SynthPop$new(1L, design)
1756742808449:source("./global.R")
1756742893658:design <- Design$new("./inputs/sim_design_docker.yaml")
1756742893682:# RR ----
1756742893682:# Create a named list of Exposure objects for the files in ./inputs/RR
1756742893682:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1756742893685:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1756742895117:names(RR) <- sapply(RR, function(x) x$get_name())
1756742895120:invisible(future_lapply(RR, function(x) {
1756742895121:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1756742895121:},
1756742895121:future.seed = 627524136L))
1756742898138:# # NOTE smooth cannot be exported to Design for now, because the first time
1756742898138:# # this parameter changes we need logic to overwrite unsmoothed files
1756742898138:rm(fl)
1756742898139:#
1756742898139:# # Generate diseases ----
1756742898139:diseases <- lapply(design$sim_prm$diseases, function(x) {
1756742898139:x[["design_"]] <- design
1756742898139:x[["RR"]] <- RR
1756742898139:do.call(Disease$new, x)
1756742898140:})
1756742988184:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1756742988185:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1756742988185:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1756742988185:scenario_suffix_for_pop <- scenario_name
1756742988185:list(
1756742988185:"exposures"          = design_$sim_prm$exposures,
1756742988186:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1756742988186:"scenario"           = scenario_name,
1756742988186:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1756742988186:"init_year"          = design_$sim_prm$init_year,
1756742988186:"pids"               = "pid",
1756742988186:"years"              = "year",
1756742988187:"ages"               = "age",
1756742988187:"ageL"               = design_$sim_prm$ageL,
1756742988187:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1756742988187:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1756742988187:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1756742988188:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1756742988188:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1756742988188:)
1756742988188:}
1756742988188:# sim <- SynthPop$new(0L, design)
1756742988189:# sim$write_synthpop(1:500)
1756742988189:# sim$delete_synthpop(NULL)
1756742988189:# ll <- sim$gen_synthpop_demog(design)
1756742988189:#TODO include informative error to check whether exposure table is matching data
1756742988189:sp  <- SynthPop$new(1L, design)
1757760890937:source("./global.R")
1757760988739:design <- Design$new("./inputs/sim_design_docker.yaml")
1757760988768:# RR ----
1757760988768:# Create a named list of Exposure objects for the files in ./inputs/RR
1757760988768:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1757760988772:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1757760990012:names(RR) <- sapply(RR, function(x) x$get_name())
1757760990014:invisible(future_lapply(RR, function(x) {
1757760990014:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1757760990014:},
1757760990015:future.seed = 627524136L))
1757760996551:# # NOTE smooth cannot be exported to Design for now, because the first time
1757760996551:# # this parameter changes we need logic to overwrite unsmoothed files
1757760996551:rm(fl)
1757760996552:#
1757760996552:# # Generate diseases ----
1757760996552:diseases <- lapply(design$sim_prm$diseases, function(x) {
1757760996553:x[["design_"]] <- design
1757760996553:x[["RR"]] <- RR
1757760996553:do.call(Disease$new, x)
1757760996554:})
1757761086993:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1757761086993:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1757761086993:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1757761086993:scenario_suffix_for_pop <- scenario_name
1757761086993:list(
1757761086994:"exposures"          = design_$sim_prm$exposures,
1757761086994:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1757761086994:"scenario"           = scenario_name,
1757761086994:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1757761086994:"init_year"          = design_$sim_prm$init_year,
1757761086994:"pids"               = "pid",
1757761086995:"years"              = "year",
1757761086995:"ages"               = "age",
1757761086995:"ageL"               = design_$sim_prm$ageL,
1757761086995:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1757761086995:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1757761086995:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1757761086996:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1757761086996:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1757761086996:)
1757761086996:}
1757761086996:# sim <- SynthPop$new(0L, design)
1757761086996:# sim$write_synthpop(1:500)
1757761086997:# sim$delete_synthpop(NULL)
1757761086997:# ll <- sim$gen_synthpop_demog(design)
1757761086997:#TODO include informative error to check whether exposure table is matching data
1757761086997:sp  <- SynthPop$new(1L, design)
1757761136370:lapply(diseases, function(x) {   # run all the functions on all the diseases
1757761136370:print(x$name)
1757761136370:x$gen_parf(sp, design)$
1757761136371:set_init_prvl(sp, design)$
1757761136371:set_rr(sp, design)$
1757761136371:set_incd_prb(sp, design)$
1757761136371:set_dgns_prb(sp, design)$
1757761136371:set_mrtl_prb(sp, design)
1757761136372:})
1757761188622:# qsave(sp, "./simulation/tmp.qs")
1757761188623:# sp <- qread("./simulation/tmp.qs")
1757761188623:l <- mk_scenario_init2("", diseases, sp, design)   # define an empty scenario
1757761189557:simcpp(sp$pop, l, sp$mc) # the actual simulation happens here, flips all the coins
1757761446616:# Load packages
1757761446616:source("./global.R")
1757761531492:# Load scenario and sensitivity analyses functions
1757761531493:source("./auxil/scenarios_GLP_uncertain.R")
1757761536719:runif(1)
1757761536720:# New runs?
1757761536720:new_runs <- TRUE
1757761536720:new_export <- TRUE
1757761575102:if(new_runs){
1757761575103:# Create batches for batched simulation
1757761575103:batch_size <- 10
1757761575103:iterations <- 300
1757761575103:first_iteration <- 1
1757761575103:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757761575104:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757761575104:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757761575104:}
1757761593032:if(new_runs){
1757761593033:# Create batches for batched simulation
1757761593033:batch_size <- 10
1757761593033:iterations <- 20
1757761593034:first_iteration <- 1
1757761593034:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757761593034:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757761593034:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757761593035:}
1757761598964:analysis_name <- "GLP_Test"
1757761600247:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757762620230:if(new_runs){
1757762620232:for(i in batches){
1757762620233:scenario_fn <- scenario_0_fn
1757762620233:IMPACTncd$
1757762620234:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757762620235:scenario_fn <- scenario_1_fn
1757762620236:IMPACTncd$
1757762620237:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757762620237:# scenario_fn <- scenario_2_fn
1757762620238:#
1757762620238:# IMPACTncd$
1757762620239:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757762620239:#
1757762620240:# scenario_fn <- scenario_3_fn
1757762620240:#
1757762620241:# IMPACTncd$
1757762620241:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757762620242:#
1757762620242:# scenario_fn <- scenario_4_fn
1757762620243:#
1757762620244:# IMPACTncd$
1757762620245:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757762620245:}
1757762620246:}
1757764603050:source("./global.R")
1757764750531:design <- Design$new("./inputs/sim_design_docker.yaml")
1757764750561:# RR ----
1757764750561:# Create a named list of Exposure objects for the files in ./inputs/RR
1757764750562:fl <- list.files(path = "./inputs/RR", pattern = ".csvy$", full.names = TRUE)
1757764750567:RR <- future_lapply(fl, Exposure$new, design,future.seed = 950480304L)
1757764752192:names(RR) <- sapply(RR, function(x) x$get_name())
1757764752195:invisible(future_lapply(RR, function(x) {
1757764752195:x$gen_stochastic_effect(design, overwrite = TRUE, smooth = FALSE)
1757764752195:},
1757764752195:future.seed = 627524136L))
1757764754865:# # NOTE smooth cannot be exported to Design for now, because the first time
1757764754865:# # this parameter changes we need logic to overwrite unsmoothed files
1757764754865:rm(fl)
1757764754866:#
1757764754866:# # Generate diseases ----
1757764754866:diseases <- lapply(design$sim_prm$diseases, function(x) {
1757764754867:x[["design_"]] <- design
1757764754867:x[["RR"]] <- RR
1757764754867:do.call(Disease$new, x)
1757764754868:})
1757764847113:names(diseases) <- sapply(design$sim_prm$diseases, `[[`, "name")
1757764847113:mk_scenario_init2 <- function(scenario_name, diseases_, sp, design_) {
1757764847113:# scenario_suffix_for_pop <- paste0("_", scenario_name) # TODO get suffix from design
1757764847113:scenario_suffix_for_pop <- scenario_name
1757764847113:list(
1757764847113:"exposures"          = design_$sim_prm$exposures,
1757764847114:"scenarios"          = design_$sim_prm$scenarios, # to be generated programmatically
1757764847114:"scenario"           = scenario_name,
1757764847114:"kismet"             = design_$sim_prm$kismet, # If TRUE random numbers are the same for each scenario.
1757764847114:"init_year"          = design_$sim_prm$init_year,
1757764847114:"pids"               = "pid",
1757764847114:"years"              = "year",
1757764847114:"ages"               = "age",
1757764847114:"ageL"               = design_$sim_prm$ageL,
1757764847115:"all_cause_mrtl"     = paste0("all_cause_mrtl", scenario_suffix_for_pop),
1757764847115:"cms_score"          = paste0("cms_score", scenario_suffix_for_pop),
1757764847115:"cms_count"          = paste0("cms_count", scenario_suffix_for_pop),
1757764847115:"strata_for_outputs" = c("pid", "year", "age", "sex"),
1757764847115:"diseases"           = lapply(diseases_, function(x) x$to_cpp(sp, design_))
1757764847115:)
1757764847115:}
1757764847116:# sim <- SynthPop$new(0L, design)
1757764847116:# sim$write_synthpop(1:500)
1757764847116:# sim$delete_synthpop(NULL)
1757764847116:# ll <- sim$gen_synthpop_demog(design)
1757764847116:#TODO include informative error to check whether exposure table is matching data
1757764847116:sp  <- SynthPop$new(1L, design)
1757764891313:lapply(diseases, function(x) {   # run all the functions on all the diseases
1757764891313:print(x$name)
1757764891313:x$gen_parf(sp, design)$
1757764891314:set_init_prvl(sp, design)$
1757764891314:set_rr(sp, design)$
1757764891314:set_incd_prb(sp, design)$
1757764891315:set_dgns_prb(sp, design)$
1757764891315:set_mrtl_prb(sp, design)
1757764891315:})
1757764932917:transpose(sp$pop[, lapply(.SD, anyNA)], keep.names = "rn")[(V1)] # look for NAs, if NAs, debug
1757764938045:# Load packages
1757764938045:source("./global.R")
1757765046487:# Load scenario and sensitivity analyses functions
1757765046487:source("./auxil/scenarios_GLP_uncertain.R")
1757765047603:# Initiate .Random.seed for safety
1757765047604:runif(1)
1757765048404:# New runs?
1757765048404:new_runs <- TRUE
1757765049493:new_export <- TRUE
1757765060860:if(new_runs){
1757765060860:# Create batches for batched simulation
1757765060861:batch_size <- 10
1757765060861:iterations <- 20
1757765060861:first_iteration <- 1
1757765060862:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757765060862:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757765060862:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757765060862:}
1757765060864:analysis_name <- "GLP_Test"
1757765060864:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757766376083:# Load packages
1757766376083:source("./global.R")
1757766451882:# Load scenario and sensitivity analyses functions
1757766451882:source("./auxil/scenarios_GLP_uncertain.R")
1757766457481:# Initiate .Random.seed for safety
1757766457481:runif(1)
1757766457481:# New runs?
1757766457481:new_runs <- TRUE
1757766457482:new_export <- TRUE
1757766462856:if(new_runs){
1757766462856:# Create batches for batched simulation
1757766462856:batch_size <- 10
1757766462856:iterations <- 20
1757766462857:first_iteration <- 1
1757766462857:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757766462857:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757766462857:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757766462857:}
1757766462859:analysis_name <- "GLP_Test"
1757766462859:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757766556481:if(new_runs){
1757766556481:for(i in batches){
1757766556481:scenario_fn <- scenario_0_fn
1757766556482:IMPACTncd$
1757766556482:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757766556482:scenario_fn <- scenario_1_fn
1757766556482:IMPACTncd$
1757766556483:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757766556484:# scenario_fn <- scenario_2_fn
1757766556485:#
1757766556485:# IMPACTncd$
1757766556485:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757766556485:#
1757766556486:# scenario_fn <- scenario_3_fn
1757766556486:#
1757766556486:# IMPACTncd$
1757766556486:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757766556486:#
1757766556487:# scenario_fn <- scenario_4_fn
1757766556487:#
1757766556487:# IMPACTncd$
1757766556487:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757766556487:}
1757766556487:}
1757924917235:# Load packages
1757924917236:source("./global.R")
1757925166664:# Load scenario and sensitivity analyses functions
1757925166665:source("./auxil/scenarios_GLP_uncertain.R")
1757925170426:# Initiate .Random.seed for safety
1757925170427:runif(1)
1757925170432:# New runs?
1757925170432:new_runs <- TRUE
1757925170433:new_export <- TRUE
1757925178244:if(new_runs){
1757925178245:# Create batches for batched simulation
1757925178245:batch_size <- 10
1757925178245:iterations <- 20
1757925178245:first_iteration <- 1
1757925178246:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757925178246:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757925178246:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757925178246:}
1757925178256:analysis_name <- "GLP_Test"
1757925178256:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757926968520:# Load packages
1757926968521:source("./global.R")
1757927592733:# Load scenario and sensitivity analyses functions
1757927592733:source("./auxil/scenarios_GLP_uncertain.R")
1757927593693:# Initiate .Random.seed for safety
1757927593693:runif(1)
1757927595239:# New runs?
1757927595239:new_runs <- TRUE
1757927595906:new_export <- TRUE
1757927605515:if(new_runs){
1757927605516:# Create batches for batched simulation
1757927605516:batch_size <- 10
1757927605516:iterations <- 5
1757927605516:first_iteration <- 1
1757927605517:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757927605517:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757927605517:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757927605517:}
1757927610538:analysis_name <- "GLP_Test"
1757927610539:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757927872409:if(new_runs){
1757927872410:for(i in batches){
1757927872411:scenario_fn <- scenario_0_fn
1757927872411:IMPACTncd$
1757927872411:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757927872412:scenario_fn <- scenario_1_fn
1757927872413:IMPACTncd$
1757927872413:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757927872414:# scenario_fn <- scenario_2_fn
1757927872414:#
1757927872414:# IMPACTncd$
1757927872415:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757927872415:#
1757927872415:# scenario_fn <- scenario_3_fn
1757927872415:#
1757927872416:# IMPACTncd$
1757927872416:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757927872416:#
1757927872416:# scenario_fn <- scenario_4_fn
1757927872417:#
1757927872417:# IMPACTncd$
1757927872417:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757927872418:}
1757927872418:}
1757928271737:if(new_runs){
1757928271738:for(i in batches){
1757928271738:scenario_fn <- scenario_0_fn
1757928271739:IMPACTncd$
1757928271739:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757928271740:scenario_fn <- scenario_1_fn
1757928271741:IMPACTncd$
1757928271741:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757928271742:# scenario_fn <- scenario_2_fn
1757928271742:#
1757928271742:# IMPACTncd$
1757928271743:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757928271744:#
1757928271744:# scenario_fn <- scenario_3_fn
1757928271745:#
1757928271745:# IMPACTncd$
1757928271746:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757928271746:#
1757928271747:# scenario_fn <- scenario_4_fn
1757928271747:#
1757928271747:# IMPACTncd$
1757928271748:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757928271748:}
1757928271749:}
1757928516708:# Load packages
1757928516709:source("./global.R")
1757928621068:# Load scenario and sensitivity analyses functions
1757928621068:source("./auxil/scenarios_GLP_uncertain.R")
1757928964775:##################################################################################################################
1757928964776:#----------------------------------------------------------------------------------------------------------------#
1757928964776:#-----------------------------------------    Semaglutide Modelling    ------------------------------------------#
1757928964776:#----------------------------------------------------------------------------------------------------------------#
1757928964776:#-----------------------------------    Scenario 1: Individual-level CEA     ------------------------------------#
1757928964777:#----------------------------------------------------------------------------------------------------------------#
1757928964777:##################################################################################################################
1757928964777:scenario_0_fn <- function(sp) {
1757928964777:sp$pop[, c("bmi_delta", "sbp_delta", "tchol_delta") := 0]
1757928964778:}
1757928970815:##################################################################################################################
1757928970815:#----------------------------------------------------------------------------------------------------------------#
1757928970815:#-----------------------------------------    Semaglutide Modelling    ------------------------------------------#
1757928970816:#----------------------------------------------------------------------------------------------------------------#
1757928970816:#-----------------------------------    Scenario 1: Individual-level CEA     ------------------------------------#
1757928970816:#----------------------------------------------------------------------------------------------------------------#
1757928970816:##################################################################################################################
1757928970817:scenario_0_fn <- function(sp) {
1757928970817:sp$pop[, c("bmi_delta", "sbp_delta", "tchol_delta") := 0]
1757928970818:}
1757928970819:#scenario_0_fn(sp)
1757928970819:### Scenario 1 - Cost-effectiveness analysis of semaglutide 2.4 mg for weight management in German adult population
1757928970819:scenario_1_fn <- function(sp) {
1757928970820:# Set scenario variables #
1757928970820:###########################################################################################################
1757928970820:# Semag scenario variables:
1757928970820:# 1. Baseline year: 2024
1757928970821:# 2. Intervention year: 2025 (years of drug roll-out)
1757928970821:# 3. simulation horizon: 20 years (the end of simulation could be 2043)
1757928970821:# 4. Eligibility criteria: BMI >= 35
1757928970821:# 5. Treatment uptake_rates:
1757928970821:#    a) For CEA: 100 % uptake for the eligible patients at the year of drug roll-out (2025)
1757928970822:#    b) For Budget impact: time-varying
1757928970822:# 6. Efficacy input trajectory (BMI, SBP, total cholesterol) (*uncertainty)
1757928970822:###########################################################################################################
1757928970822:# Efficacy for bmi at 1st year after treatment
1757928970822:tbl <- read_fst("./inputs/other_parameters/bmi_1y_samples.fst", as.data.table = TRUE)
1757928970823:bmi_1y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_1y"])
1757928970823:# Efficacy for bmi at 2nd year after treatment
1757928970823:tbl <- read_fst("./inputs/other_parameters/bmi_2y_samples.fst", as.data.table = TRUE)
1757928970824:bmi_2y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_2y"])
1757928970824:# Efficacy for bmi at 3rd year after treatment
1757928970824:tbl <- read_fst("./inputs/other_parameters/bmi_3y_samples.fst", as.data.table = TRUE)
1757928970824:bmi_3y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_3y"])
1757928970825:# Efficacy for bmi at 4th year after treatment
1757928970825:tbl <- read_fst("./inputs/other_parameters/bmi_4y_samples.fst", as.data.table = TRUE)
1757928970825:bmi_4y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_4y"])
1757928970826:# Efficacy for SBP at 1st year after treatment
1757928970826:tbl <- read_fst("./inputs/other_parameters/sbp_1y_samples.fst", as.data.table = TRUE)
1757928970826:sbp_1y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_1y"])
1757928970827:# Efficacy for SBP at 2nd year of treatment
1757928970827:tbl <- read_fst("./inputs/other_parameters/sbp_2y_samples.fst", as.data.table = TRUE)
1757928970827:sbp_2y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_2y"])
1757928970828:# Efficacy for total cholesterol at 1st year of treatment
1757928970828:tbl <- read_fst("./inputs/other_parameters/tchol_1y_samples.fst", as.data.table = TRUE)
1757928970828:tchol_1y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_1y"])
1757928970829:# Efficacy for total cholesterol at 2nd year of treatment
1757928970829:tbl <- read_fst("./inputs/other_parameters/tchol_2y_samples.fst", as.data.table = TRUE)
1757928970829:tchol_2y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_2y"])
1757928970829:###########################################################################################################
1757928970830:# a variable for how long it has been since the baseline (2024)
1757928970830:baseline_yr <- 24 ## it's 2024, but all years should be relative to year 2000
1757928970830:sp$pop[, ys_rollout := year - baseline_yr] # baseline_yr == 2024 / year == 24 --> baseline year
1757928970831:# a variable for uptake rates based on years after drug roll-out
1757928970832:# * For CEA: 100 % uptake for the eligible patients at the first year of drug roll-out (year == 25 --> rollout year)
1757928970832:# * This uptake rate is independent of individual simulation history, it only depends on years after roll-out
1757928970832:sp$pop[, uptake_rate := ifelse(ys_rollout == 1, 1, 0)] # Set the uptake_rate to be 100% and only possible in year 2025 in CEA
1757928970833:# a variable for defining individual's eligibility for accessing Semaglutide by BMI
1757928970833:sp$pop[, eligible_bi := ifelse(bmi_curr_xps >= 35 & age <= 80, 1, 0)]
1757928970833:# a variable for the uptake of the drug conditioning on meeting eligibility (person_year)
1757928970834:sp$pop[, uptake_psyr := ifelse(eligible_bi ==1, rbinom(.N, size = 1, prob = uptake_rate), 0)]
1757928970834:# a variable for the once-in-a-lifetime uptake during an individual's simulation years
1757928970835:sp$pop[, uptake_one := 0]
1757928970835:sp$pop[uptake_psyr == 1, uptake_one := as.integer(.I == .I[which.min(year)]), by = pid]
1757928970835:### In this testing, only two ids got the treatment: pid 156, 175
1757928970836:# a variable for the year someone uptaking the drug
1757928970837:sp$pop[, anchor_year:=year[uptake_one == 1], by = pid]
1757928970837:# a variable for the year someone enters the synthetic population
1757928970838:sp$pop[, entry_year:= min(year), by = pid]
1757928970838:# a variable for theorectical treatment trajectory
1757928970839:### Step 0: Initialize the column
1757928970839:sp$pop[, trtm_theo := NA_integer_]
1757928970840:### Step 1: Identify first year of treatment uptake
1757928970840:sp$pop[uptake_one == 1, trtm_theo := fifelse(anchor_year > entry_year, 1,0)]
1757928970841:### Step 2: Fill the sequence in subsequent years
1757928970841:sp$pop[, trtm_theo := fifelse(cumsum(!is.na(trtm_theo)) > 0,   # cumsum(): computes a cumulative count of non-NA entries:
1757928970842:# fill in a sequence starting from the first non-NA value
1757928970842:seq_len(.N) - min(which(!is.na(trtm_theo))) + fifelse(anchor_year > entry_year, 1L, 0L),
1757928970842:NA_integer_),
1757928970843:by = pid]
1757928970843:### Step 3: Replace NAs with 0
1757928970844:sp$pop[, trtm_theo := fifelse(is.na(trtm_theo), 0, trtm_theo)]
1757928970844:#scenario_1_fn(sp) # Works!
1757928970845:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year >= 25 & eligible_bi ==1, unique(pid)]]
1757928970845:#test_uptake <- sp$pop[pid %in% sp$pop[uptake_one == 1, unique(pid)]]
1757928970846:########################################################################################
1757928970846:################################          BMI         ##################################
1757928970846:########################################################################################
1757928970847:# a variable for the change in BMI after the uptake of semaglutide
1757928970847:sp$pop[, `:=`(
1757928970848:bmi_delta = fcase(
1757928970848:### All values until year 5, are % weight loss relative to baseline
1757928970848:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1757928970849:trtm_theo == 1, bmi_1y,  ### replace '-0.149' with 'bmi_1y', and link to the uncertainty file: mc + bmi_1y, (Jane today)
1757928970849:### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): 14.9% weight loss
1757928970850:trtm_theo == 2, bmi_2y,  ### replace '-0.152' with 'bmi_2y', and link to the uncertainty file: mc + bmi_2y, (Jane today)
1757928970850:### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): 15.2% weight loss
1757928970850:trtm_theo == 3, bmi_3y,  ### STEP 1 extension: regain 2/3 of weight loss in 1st year treatment cessation
1757928970851:###
1757928970851:trtm_theo == 4, bmi_4y,  ### weight regain at 2nd year treatment cessation (uncertainty?)
1757928970852:trtm_theo >= 5, 0        ### weight return to baseline weight by 3rd year treatment cessation (uncertainty?)
1757928970852:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (bmi_curr_xps)
1757928970852:))
1757928970853:]
1757928970854:# a variable for each individual's baseline weight (baseline: year == 24 / ys_rollout == 0)
1757928970854:# ------------------------------------------ Aug 22, 2025, Jane ------------------------------------------------- #
1757928970855:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1757928970855:# *and, some individuals came in later than year 24, and because they have a chance to uptake drug begining year 25
1757928970856:# *they might already uptake the drug at the first year, which means they won't have a year (anchor-1),
1757928970856:# *so what shall we use as a baseline BMI value here...
1757928970857:sp$pop[, baseline_bmi := {              # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928970857:anchor <- unique(anchor_year)         # So we can distinguish people who have entry at year 24 and who do not
1757928970858:if (is.na(anchor)) {                  # If no anchor is found,
1757928970858:bmi_curr_xps                        # the function simply returns the original bmi_curr_xps as-is
1757928970858:} else {                              # If yes anchor is found
1757928970859:bmi_curr_xps[year == (year[trtm_theo == 1][1] - 1)] # baseline_bmi will take the BMI at the year before trtm_theo==1
1757928970859:}
1757928970860:}, by = pid] #Works!
1757928970861:###############################################################################################################
1757928970861:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1757928970861:###############################################################################################################
1757928970862:sp$pop[, bmi_shift := {             # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928970862:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1757928970863:# return a vector that gets assigned to 'bmi_shift' for the rows in that group
1757928970863:anchor <- unique(anchor_year)     # This line finds a single anchor year (e.g., year 30) for each person.
1757928970864:if (is.na(anchor)) {              # If no anchor is found (to avoid breaking your logic when a person doesn't uptake the drug)
1757928970864:bmi_curr_xps                    # the function simply returns the original bmi_curr_xps as-is
1757928970865:} else {                          # If yes anchor is found, You shift the bmi_curr_xps backward in time (type='lag')
1757928970865:shift(bmi_curr_xps, type = "lag", n = 5) # by 5 years: 5 years is the duration of efficacy inputs (weight loss and reboud)
1757928970865:}
1757928970866:}, by = pid] #Works!
1757928970866:###############################################################################################################
1757928970867:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1757928970867:###############################################################################################################
1757928970868:# a variable for new weight after applying efficacy input during treatment influenced period
1757928970869:sp$pop[, new_bmi := {
1757928970870:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1757928970871:if (is.na(anchor)) {                                      # If no anchor is found,
1757928970872:bmi_curr_xps                                            # the function simply returns the original bmi_curr_xps as-is
1757928970873:} else {                                                  # If yes anchor is found,
1757928970873:fcase(                                                  # We need to assign value to the' new_bmi' based on the time periods
1757928970874:year < anchor,                       bmi_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1757928970875:year >= anchor & year <= anchor + 4, baseline_bmi*(1 + bmi_delta),  # During the 5 years where treatment effects manifest
1757928970876:year > anchor + 4,                   bmi_shift        # After rebound to baseline: revert to the original bmi_curr_xps
1757928970877:)
1757928970878:}
1757928970879:}, by = pid]
1757928970880:#scenario_1_fn(sp) # Works!
1757928970881:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year >= 25 & eligible_bi ==1, unique(pid)]]
1757928970882:#test_uptake <- sp$pop[pid %in% sp$pop[uptake_one == 1, unique(pid)]]
1757928970884:# Overwriting the original bmi exposure column with the newly created bmi column
1757928970885:sp$pop[, bmi_curr_xps := new_bmi]
1757928970887:########################################################################################
1757928970888:################################          SBP         ##################################
1757928970889:########################################################################################
1757928970890:# a variable for the change in SBP after the uptake of semaglutide
1757928970891:sp$pop[, `:=`(
1757928970892:sbp_delta = fcase(
1757928970892:### All values until year 5, are % weight loss relative to baseline
1757928970893:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1757928970894:trtm_theo == 1, sbp_1y,    ### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): mean decrease of 6.2 mmHg from baseline
1757928970894:trtm_theo == 2, sbp_2y,    ### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): mean decrease of 5.7 mmHg from baseline
1757928970895:trtm_theo >= 3, 0        ### STEP 1 extension: assume mean SBP will revert to baseline level after one year without treatment
1757928970896:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (sbp_curr_xps)
1757928970897:))
1757928970897:]
1757928970899:# a variable for each individual's baseline SBP (baseline: year == 24 / ys_rollout == 0)
1757928970900:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1757928970901:sp$pop[, baseline_sbp := {                # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928970901:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1757928970902:if (is.na(anchor)) {                    # If no anchor is found,
1757928970903:sbp_curr_xps                          # the function simply returns the original sbp_curr_xps as-is
1757928970904:} else {                                # If yes anchor is found, baseline_sbp will take the sbp at year 24
1757928970905:sbp_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1757928970906:}
1757928970906:}, by = pid] #Works!
1757928970908:###############################################################################################################
1757928970909:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1757928970910:###############################################################################################################
1757928970911:sp$pop[, sbp_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928970912:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1757928970913:# return a vector that gets assigned to 'sbp_shift' for the rows in that group
1757928970914:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1757928970915:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1757928970916:sbp_curr_xps                       # the function simply returns the original sbp_curr_xps as-is
1757928970917:} else {                             # If yes anchor is found, You shift the sbp_curr_xps backward in time (type='lag')
1757928970918:shift(sbp_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in SBP and rebound)
1757928970919:}
1757928970920:}, by = pid] #Works!
1757928970923:#  A if_else function inside of :={} for creating a new variable
1757928970924:#  if(condition) {
1757928970925:#   what should happen if condition is TRUE
1757928970926:#  } else {
1757928970926:#   what should happen if condition is FALSE
1757928970927:#  }
1757928970928:###############################################################################################################
1757928970929:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1757928970930:###############################################################################################################
1757928970932:# a variable for new weight after applying efficacy input during treatment influenced period
1757928970933:sp$pop[, new_sbp := {
1757928970934:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1757928970935:if (is.na(anchor)) {                                      # If no anchor is found,
1757928970935:sbp_curr_xps                                            # the function simply returns the original sbp_curr_xps as-is
1757928970936:} else {                                                  # If yes anchor is found,
1757928970937:fcase(                                                  # We need to assign value to the 'new_sbp' based on the time periods
1757928970938:year < anchor,                       sbp_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1757928970939:year >= anchor & year <= anchor + 2, baseline_sbp + sbp_delta,  # During the 2 years where treatment effect manifest
1757928970940:year >= anchor + 3,                  sbp_shift        # After sbp rebound to baseline: revert to the original sbp_curr_xps
1757928970941:)
1757928970942:}
1757928970943:}, by = pid]
1757928970944:# Overwriting the original sbp exposure column with the newly created sbp column
1757928970945:sp$pop[, sbp_curr_xps := new_sbp]
1757928970947:########################################################################################
1757928970948:###############################          Tchol         #################################
1757928970949:########################################################################################
1757928970949:# a variable for the change in SBP after the uptake of semaglutide
1757928970950:sp$pop[, `:=`(
1757928970951:tchol_delta = fcase(
1757928970951:trtm_theo == 0, 0,        ### Baseline year, the year patients become eligible
1757928970952:trtm_theo == 1, tchol_1y,    ### 1st year of treatment: ITT effects from STEP 1: mean decrease of 3% from baseline
1757928970953:trtm_theo == 2, tchol_2y,   ### 2nd year of treatment: ITT effects from STEP 5: mean decrease of 3.3% from baseline
1757928970954:trtm_theo >= 3, 0         ### STEP 1 extension: assume mean tchol will revert to baseline level after one year without treatment
1757928970955:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (tchol_curr_xps)
1757928970956:))
1757928970957:]
1757928970958:# a variable for each individual's baseline Tchol (baseline: year == 24 / ys_rollout == 0)
1757928970958:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1757928970959:sp$pop[, baseline_tchol := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928970960:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1757928970961:if (is.na(anchor)) {                    # If no anchor is found,
1757928970962:tchol_curr_xps                        # the function simply returns the original tchol_curr_xps as-is
1757928970963:} else {                                # If yes anchor is found, baseline_tchol will take the tchol at year 24
1757928970964:tchol_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1757928970965:}
1757928970966:}, by = pid] #Works!
1757928970969:###############################################################################################################
1757928970970:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1757928970970:###############################################################################################################
1757928970971:sp$pop[, tchol_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928970971:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1757928970972:# return a vector that gets assigned to 'tchol_shift' for the rows in that group
1757928970973:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1757928970974:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1757928970975:tchol_curr_xps                       # the function simply returns the original tchol_curr_xps as-is
1757928970975:} else {                             # If yes anchor is found, You shift the tchol_curr_xps backward in time (type='lag')
1757928970976:shift(tchol_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in tchol and reboud)
1757928970977:}
1757928970977:}, by = pid] #Works!
1757928970978:# test <- sp$pop[pid %in% c(156, 175)]
1757928970979:###############################################################################################################
1757928970980:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1757928970981:###############################################################################################################
1757928970984:# a variable for new weight after applying efficacy input during treatment influenced period
1757928970985:sp$pop[, new_tchol := {
1757928970986:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1757928970986:if (is.na(anchor)) {                                      # If no anchor is found,
1757928970987:tchol_curr_xps                                          # the function simply returns the original tchol_curr_xps as-is
1757928970988:} else {                                                  # If yes anchor is found,
1757928970990:fcase(                                                  # We need to assign value to the 'new_tchol' based on the time periods
1757928970991:year < anchor,                       tchol_curr_xps,  # Before anchor year/uptake: original values (including baseline year)
1757928970992:year >= anchor & year <= anchor + 2, baseline_tchol*(1 + tchol_delta),  # During the 2 years where treatment effect manifest
1757928970993:year >= anchor + 3,                  tchol_shift      # After tchol rebound to baseline: revert to the original tchol_curr_xps
1757928970994:)
1757928970996:}
1757928970997:}, by = pid]
1757928970998:# Overwriting the original tchol exposure column with the newly created tchol column
1757928970999:sp$pop[, tchol_curr_xps := new_tchol]
1757928971000:### Jane Aug 2025, test scenario on sp$pop --> Looks like until here everything worked!!!
1757928971001:##################### Get rid of unnecessary variables ##########################
1757928971002:# Delete unnecessary variables from synthpop #
1757928971002:sp$pop[, c("rankstat_sbp", "rankstat_tchol", "ys_rollout", "uptake_rate",
1757928971003:"eligible_bi", "uptake_psyr", "anchor_year",
1757928971004:"entry_year", "baseline_bmi", "bmi_shift", "new_bmi",
1757928971005:"baseline_sbp", "sbp_shift", "new_sbp", "baseline_tchol",
1757928971005:"tchol_shift", "new_tchol") := NULL]
1757928971007:}
1757928971009:# Good to get rid of all the intermediate variables,which were created to get to the new exposure column (tchol_curr_xps)
1757928971009:# The model runs faster without them
1757928971009:# Keep the variables needed for further analysis
1757928971009:#scenario_1_fn(sp) # Works!
1757928971010:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year >= 25 & eligible_bi ==1, unique(pid)]]
1757928971010:#test_uptake <- sp$pop[pid %in% sp$pop[uptake_one == 1, unique(pid)]]
1757928971010:##################################################################################################################
1757928971010:#----------------------------------------------------------------------------------------------------------------#
1757928971010:#-----------------------------------------    Semaglutide Modelling    ------------------------------------------#
1757928971010:#----------------------------------------------------------------------------------------------------------------#
1757928971010:#-----------------------------------------   Scenario 2: Budget impact     --------------------------------------#
1757928971011:#----------------------------------------------------------------------------------------------------------------#
1757928971011:##################################################################################################################
1757928971011:##################################################################################################################
1757928971011:####                                                                                                          ####
1757928971011:####           2. Budget impact scenario:                                                                     ####
1757928971011:####              - Open cohort. Baseline year: 2024, Drug roll-out year: 2025                                ####
1757928971012:####              - Uptake possible at any time point after roll-out                                          ####
1757928971012:####              - Eligibility criteria: BMI >= 35 (eligible_bi), assessed at each year                      ####
1757928971012:####              ############################################################################                ####
1757928971012:####              ** Time-varying uptake rates (by Year after roll-out):                                      ####
1757928971012:####                   Year 1-2 (2025-2026): 20%  - Moderate uptake for early adopters                        ####
1757928971013:####                   Year 3-5 (2027-2029): 40%  - Higher uptake as awareness increases                      ####
1757928971013:####                   Year >5  (>2030)    : 60%  - Potential plateau                                         ####
1757928971013:####              ** ??? This could be problematic, because:                                                  ####
1757928971014:####              ** !!! The overall prevalence in the population over a time period is different from        ####
1757928971014:####              ** !!! the probability of individual uptake each year (incidence)                           ####
1757928971014:####              ############################################################################                ####
1757928971014:####              Assumptions on the time-varying uptake rate:                                                ####
1757928971015:####              1) After 10 year, ~overall prevalence of uptake: 50-60%                                     ####
1757928971015:####              2) We will assume a 10% uptake rate every year                                              ####
1757928971015:####                 * This gives us a 58% overall uptake prevalence over 10 years, 75% over 20 ys            ####
1757928971015:####                 * This gives us a curve of declining numbers of people uptaking the drug over years      ####
1757928971016:####              ############################################################################                ####
1757928971016:####              - People can only uptake the treatment *once* during lifetime                               ####
1757928971016:####              - Treatment last for 2 years (ITT effect, no discontinuation applied to individuals)        ####
1757928971016:####              - Efficacy trajectory (weight loss--rebound--natural progression) applied identical for     ####
1757928971016:####                all eligible patients                                                                     ####
1757928971017:####              - Follow-up period: 5, 10, 20 year                                                          ####
1757928971017:####                                                                                                          ####
1757928971017:##################################################################################################################
1757928971017:##################################################################################################################
1757928971017:#### What do we need as input/function arguments in this scenario: ### Jane Aug 11
1757928971017:#### 1. lifecourse dataset, with original BMI, SBP, Cholesterol
1757928971018:####    Semag:    sppop, bmi_curr_xps, sbp_curr_xps, tchol_curr_xps
1757928971018:####
1757928971018:#### 2. Time horizon: initial year, intervention year, simulation horizon
1757928971018:####    Semag:    2013-2043, with 2024 as baseline year
1757928971018:####
1757928971018:#### 3. Policy input: Eligibility and uptake of treatment
1757928971019:####    Semag:    ys_rollout, eligible_bi, uptake_rate
1757928971019:####
1757928971019:#### 4. Efficacy input: change in BMI, SBP, Cholesterol from RCT
1757928971019:####    Semag:    efficacy input trajectory
1757928971019:####                  Treatment_y1,  xyz,     ### 1st year of treatment: ITT effects from RCT
1757928971020:####                  Treatment_y2,  xyz,     ### 2nd year of treatment: ITT effects from RCT
1757928971020:####                  Treatment_y3,  xyz,     ### Results from STEP 1 extension: waning of 2-year treatment effect
1757928971020:####                  ### The efficacy should be assigned until here, the rest we will revert to the original exposure column
1757928971020:####                  ******
1757928971020:####                  Uncertainty: consistent among estimates (with CI) from multiple RCTs,
1757928971020:####                               In each iteration, sample values from uniform distribution, and use these values
1757928971021:####                               as quantile [0. 1] to sample values from distributions of efficacy inputs
1757928971021:####                               ---> individual fixed effect (?)
1757928971021:####                  Draw random values from uniform distribution for as many MCs
1757928971021:####                  There will be one dataset / input file (?) for efficacy inputs,
1757928971021:####                  ---> In this dataset, each columns is for one efficacy inputs (for all exposures)
1757928971022:####                  One column for mc (1-1000): Col_MC  Col_Quant  Col_BMI_Y1 Col_BMI_Y2 Col_SBP_Y2 (?)
1757928971022:####                  ******
1757928971022:####
1757928971022:#### 5. lifecourse dataset, with modified exposure variables (replacing the original ones)
1757928971022:####    Semag:    bmi_curr_xps := new_bmi
1757928971023:##################################################################################################################
1757928971023:### Scenario 2 - Budget impact of semaglutide 2.4 mg for weight management in German adult population
1757928971023:scenario_2_fn <- function(sp) {
1757928971024:# Efficacy for bmi at 1st year after treatment
1757928971024:tbl <- read_fst("./inputs/other_parameters/bmi_1y_samples.fst", as.data.table = TRUE)
1757928971024:bmi_1y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_1y"])
1757928971024:# Efficacy for bmi at 2nd year after treatment
1757928971025:tbl <- read_fst("./inputs/other_parameters/bmi_2y_samples.fst", as.data.table = TRUE)
1757928971025:bmi_2y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_2y"])
1757928971025:# Efficacy for bmi at 3rd year after treatment
1757928971025:tbl <- read_fst("./inputs/other_parameters/bmi_3y_samples.fst", as.data.table = TRUE)
1757928971026:bmi_3y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_3y"])
1757928971026:# Efficacy for bmi at 4th year after treatment
1757928971026:tbl <- read_fst("./inputs/other_parameters/bmi_4y_samples.fst", as.data.table = TRUE)
1757928971026:bmi_4y <- as.numeric(tbl[mc == sp$mc_aggr, "bmi_4y"])
1757928971027:# Efficacy for SBP at 1st year after treatment
1757928971027:tbl <- read_fst("./inputs/other_parameters/sbp_1y_samples.fst", as.data.table = TRUE)
1757928971027:sbp_1y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_1y"])
1757928971028:# Efficacy for SBP at 2nd year of treatment
1757928971028:tbl <- read_fst("./inputs/other_parameters/sbp_2y_samples.fst", as.data.table = TRUE)
1757928971028:sbp_2y <- as.numeric(tbl[mc == sp$mc_aggr, "sbp_2y"])
1757928971029:# Efficacy for total cholesterol at 1st year of treatment
1757928971029:tbl <- read_fst("./inputs/other_parameters/tchol_1y_samples.fst", as.data.table = TRUE)
1757928971029:tchol_1y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_1y"])
1757928971030:# Efficacy for total cholesterol at 2nd year of treatment
1757928971030:tbl <- read_fst("./inputs/other_parameters/tchol_2y_samples.fst", as.data.table = TRUE)
1757928971030:tchol_2y <- as.numeric(tbl[mc == sp$mc_aggr, "tchol_2y"])
1757928971031:###########################################################################################################
1757928971031:# a variable for how long it has been since the baseline (2024)
1757928971031:baseline_yr <- 24 ## it's 2024, but all years should be relative to year 2000
1757928971032:sp$pop[, ys_rollout := year - baseline_yr] # baseline_yr == 2024 / year == 24 --> baseline year
1757928971032:# a variable for uptake rates based on years after drug roll-out
1757928971033:# * For Budget impact, We assume a 10% uptake rate every year
1757928971033:# * This uptake rate is independent of individual simulation history, it only depends on years after roll-out
1757928971033:sp$pop[, uptake_rate := ifelse(ys_rollout >= 1, 0.1, 0)]
1757928971034:# a variable for defining individual's eligibility for accessing Semaglutide by BMI
1757928971034:sp$pop[, eligible_bi := ifelse(bmi_curr_xps >= 35, 1, 0)]
1757928971034:# a variable for the uptake of the drug conditioning on meeting eligibility (person_year)
1757928971035:sp$pop[, uptake_psyr := ifelse(eligible_bi ==1, rbinom(.N, size = 1, prob = uptake_rate), 0)]
1757928971035:# a variable for the once-in-a-lifetime uptake during an individual's simulation years
1757928971036:sp$pop[, uptake_one := 0]
1757928971036:sp$pop[uptake_psyr == 1, uptake_one := as.integer(.I == .I[which.min(year)]), by = pid]
1757928971036:### In this testing, only two ids got the treatment: pid 156, 175
1757928971037:# a variable for the year someone uptaking the drug
1757928971037:sp$pop[, anchor_year:=year[uptake_one == 1], by = pid]
1757928971038:# a variable for the year someone enters the synthetic population
1757928971038:sp$pop[, entry_year:= min(year), by = pid]
1757928971039:# a variable for theorectical treatment trajectory
1757928971039:### Step 0: Initialize the column
1757928971039:sp$pop[, trtm_theo := NA_integer_]
1757928971039:### Step 1: Identify first year of treatment uptake
1757928971040:sp$pop[uptake_one == 1, trtm_theo := fifelse(anchor_year > entry_year, 1,0)]
1757928971040:### Step 2: Fill the sequence in subsequent years
1757928971040:sp$pop[, trtm_theo := fifelse(cumsum(!is.na(trtm_theo)) > 0,   # cumsum(): computes a cumulative count of non-NA entries:
1757928971041:# fill in a sequence starting from the first non-NA value
1757928971041:seq_len(.N) - min(which(!is.na(trtm_theo))) + fifelse(anchor_year > entry_year, 1L, 0L),
1757928971041:NA_integer_),
1757928971042:by = pid]
1757928971042:### Step 3: Replace NAs with 0
1757928971042:sp$pop[, trtm_theo := fifelse(is.na(trtm_theo), 0, trtm_theo)]
1757928971043:########################################################################################
1757928971044:################################          BMI         ##################################
1757928971044:########################################################################################
1757928971044:# a variable for the change in BMI after the uptake of semaglutide
1757928971045:sp$pop[, `:=`(
1757928971045:bmi_delta = fcase(
1757928971045:### All values until year 5, are % weight loss relative to baseline
1757928971046:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1757928971046:trtm_theo == 1, bmi_1y,  ### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): 14.9% weight loss (uncertainty?)
1757928971047:trtm_theo == 2, bmi_2y,  ### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): 15.2% weight loss (uncertainty?)
1757928971047:trtm_theo == 3, bmi_3y,  ### STEP 1 extension: regain 2/3 of weight loss in 1st year treatment cessation (uncertainty?)
1757928971047:trtm_theo == 4, bmi_4y,  ### weight regain at 2nd year treatment cessation (uncertainty?)
1757928971048:trtm_theo >= 5, 0        ### weight return to baseline weight by 3rd year treatment cessation (uncertainty?)
1757928971048:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (bmi_curr_xps)
1757928971049:))
1757928971049:]
1757928971050:# a variable for each individual's baseline weight (baseline: year == 24 / ys_rollout == 0)
1757928971050:# ------------------------------------------ Aug 22, 2025, Jane ------------------------------------------------- #
1757928971050:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1757928971051:# *and, some individuals came in later than year 24, and because they have a chance to uptake drug begining year 25
1757928971051:# *they might already uptake the drug at the first year, which means they won't have a year (anchor-1),
1757928971052:# *so what shall we use as a baseline BMI value here...
1757928971052:sp$pop[, baseline_bmi := {              # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928971052:anchor <- unique(anchor_year)         # So we can distinguish people who have entry at year 24 and who do not
1757928971053:if (is.na(anchor)) {                  # If no anchor is found,
1757928971053:bmi_curr_xps                        # the function simply returns the original bmi_curr_xps as-is
1757928971054:} else {                              # If yes anchor is found
1757928971054:bmi_curr_xps[year == (year[trtm_theo == 1][1] - 1)] # baseline_bmi will take the BMI at the year before trtm_theo==1
1757928971055:}
1757928971055:}, by = pid] #Works!
1757928971056:###############################################################################################################
1757928971056:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1757928971057:###############################################################################################################
1757928971057:sp$pop[, bmi_shift := {             # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928971057:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1757928971058:# return a vector that gets assigned to 'bmi_shift' for the rows in that group
1757928971058:anchor <- unique(anchor_year)     # This line finds a single anchor year (e.g., year 30) for each person.
1757928971059:if (is.na(anchor)) {              # If no anchor is found (to avoid breaking your logic when a person doesn't uptake the drug)
1757928971059:bmi_curr_xps                    # the function simply returns the original bmi_curr_xps as-is
1757928971060:} else {                          # If yes anchor is found, You shift the bmi_curr_xps backward in time (type='lag')
1757928971060:shift(bmi_curr_xps, type = "lag", n = 5) # by 5 years: 5 years is the duration of efficacy inputs (weight loss and reboud)
1757928971061:}
1757928971061:}, by = pid] #Works!
1757928971062:###############################################################################################################
1757928971062:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1757928971063:###############################################################################################################
1757928971064:# a variable for new weight after applying efficacy input during treatment influenced period
1757928971064:sp$pop[, new_bmi := {
1757928971065:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1757928971066:if (is.na(anchor)) {                                      # If no anchor is found,
1757928971066:bmi_curr_xps                                            # the function simply returns the original bmi_curr_xps as-is
1757928971068:} else {                                                  # If yes anchor is found,
1757928971068:fcase(                                                  # We need to assign value to the' new_bmi' based on the time periods
1757928971069:year < anchor,                       bmi_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1757928971070:year >= anchor & year <= anchor + 4, baseline_bmi*(1 + bmi_delta),  # During the 5 years where treatment effects manifest
1757928971070:year > anchor + 4,                   bmi_shift        # After rebound to baseline: revert to the original bmi_curr_xps
1757928971071:)
1757928971072:}
1757928971072:}, by = pid]
1757928971073:# Overwriting the original bmi exposure column with the newly created bmi column
1757928971074:sp$pop[, bmi_curr_xps := new_bmi]
1757928971076:########################################################################################
1757928971077:################################          SBP         ##################################
1757928971078:########################################################################################
1757928971078:# a variable for the change in SBP after the uptake of semaglutide
1757928971129:sp$pop[, `:=`(
1757928971129:sbp_delta = fcase(
1757928971130:### All values until year 5, are % weight loss relative to baseline
1757928971130:trtm_theo == 0, 0,       ### Baseline year, the year patients become eligible
1757928971131:trtm_theo == 1, sbp_1y,    ### 1st year of treatment: ITT effects from STEP 1 (1 year f/u): mean decrease of 6.2 mmHg from baseline
1757928971131:trtm_theo == 2, sbp_2y,    ### 2nd year of treatment: ITT effects from STEP 5 (2 year f/u): mean decrease of 5.7 mmHg from baseline
1757928971132:trtm_theo >= 3, 0        ### STEP 1 extension: assume mean SBP will revert to baseline level after one year without treatment
1757928971132:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (sbp_curr_xps)
1757928971132:))
1757928971133:]
1757928971133:# a variable for each individual's baseline SBP (baseline: year == 24 / ys_rollout == 0)
1757928971134:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1757928971134:sp$pop[, baseline_sbp := {                # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928971135:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1757928971135:if (is.na(anchor)) {                    # If no anchor is found,
1757928971136:sbp_curr_xps                          # the function simply returns the original sbp_curr_xps as-is
1757928971136:} else {                                # If yes anchor is found, baseline_sbp will take the sbp at year 24
1757928971137:sbp_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1757928971138:}
1757928971138:}, by = pid] #Works!
1757928971139:###############################################################################################################
1757928971140:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1757928971140:###############################################################################################################
1757928971140:sp$pop[, sbp_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928971141:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1757928971142:# return a vector that gets assigned to 'sbp_shift' for the rows in that group
1757928971142:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1757928971143:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1757928971143:sbp_curr_xps                       # the function simply returns the original sbp_curr_xps as-is
1757928971144:} else {                             # If yes anchor is found, You shift the sbp_curr_xps backward in time (type='lag')
1757928971144:shift(sbp_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in SBP and rebound)
1757928971145:}
1757928971145:}, by = pid] #Works!
1757928971146:#  A if_else function inside of :={} for creating a new variable
1757928971147:#  if(condition) {
1757928971147:#   what should happen if condition is TRUE
1757928971148:#  } else {
1757928971148:#   what should happen if condition is FALSE
1757928971149:#  }
1757928971149:###############################################################################################################
1757928971150:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1757928971150:###############################################################################################################
1757928971151:# a variable for new weight after applying efficacy input during treatment influenced period
1757928971151:sp$pop[, new_sbp := {
1757928971152:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1757928971152:if (is.na(anchor)) {                                      # If no anchor is found,
1757928971153:sbp_curr_xps                                            # the function simply returns the original sbp_curr_xps as-is
1757928971154:} else {                                                  # If yes anchor is found,
1757928971155:fcase(                                                  # We need to assign value to the 'new_sbp' based on the time periods
1757928971156:year < anchor,                       sbp_curr_xps,    # Before anchor year/uptake: original values (including baseline year)
1757928971156:year >= anchor & year <= anchor + 2, baseline_sbp + sbp_delta,  # During the 2 years where treatment effect manifest
1757928971157:year >= anchor + 3,                  sbp_shift        # After sbp rebound to baseline: revert to the original sbp_curr_xps
1757928971157:)
1757928971157:}
1757928971158:}, by = pid]
1757928971159:# Overwriting the original sbp exposure column with the newly created sbp column
1757928971159:sp$pop[, sbp_curr_xps := new_sbp]
1757928971160:########################################################################################
1757928971161:###############################          Tchol         #################################
1757928971161:########################################################################################
1757928971162:# a variable for the change in SBP after the uptake of semaglutide
1757928971162:sp$pop[, `:=`(
1757928971163:tchol_delta = fcase(
1757928971164:trtm_theo == 0, 0,        ### Baseline year, the year patients become eligible
1757928971164:trtm_theo == 1, tchol_1y,    ### 1st year of treatment: ITT effects from STEP 1: mean decrease of 3% from baseline
1757928971164:trtm_theo == 2, tchol_2y,   ### 2nd year of treatment: ITT effects from STEP 5: mean decrease of 3.3% from baseline
1757928971165:trtm_theo >= 3, 0         ### STEP 1 extension: assume mean tchol will revert to baseline level after one year without treatment
1757928971165:### The efficacy inputs are assigned until here, the rest we will revert to the original exposure column (tchol_curr_xps)
1757928971166:))
1757928971166:]
1757928971167:# a variable for each individual's baseline Tchol (baseline: year == 24 / ys_rollout == 0)
1757928971168:# *but, some individuals in the dataset does not have entry at baseline_yr, they came in later than year 24
1757928971168:sp$pop[, baseline_tchol := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928971169:anchor <- unique(anchor_year)           # So we can distinguish people who have entry at year 24 and who do not
1757928971169:if (is.na(anchor)) {                    # If no anchor is found,
1757928971170:tchol_curr_xps                        # the function simply returns the original tchol_curr_xps as-is
1757928971171:} else {                                # If yes anchor is found, baseline_tchol will take the tchol at year 24
1757928971172:tchol_curr_xps[year == (year[trtm_theo == 1][1] - 1)]  # The baseline year will be (anchor - 1): one year before uptake
1757928971172:}
1757928971173:}, by = pid] #Works!
1757928971174:###############################################################################################################
1757928971174:#----------------------------  Tutorial: if_else function inside data.table  ---------------------------------#
1757928971175:###############################################################################################################
1757928971175:sp$pop[, tchol_shift := {                 # sp$pop[, ... , by = pid]: grouping the operation by pid
1757928971176:# { ... } operetion per group: inside {}, you can run any custom R code, it will
1757928971176:# return a vector that gets assigned to 'tchol_shift' for the rows in that group
1757928971177:anchor <- unique(anchor_year)        # This line finds a single anchor year (e.g., year 30) for each person.
1757928971178:if (is.na(anchor)) {                 # If no anchor is found, (This is useful to avoid breaking your logic when a person doesn't meet your anchor condition)
1757928971179:tchol_curr_xps                       # the function simply returns the original tchol_curr_xps as-is
1757928971179:} else {                             # If yes anchor is found, You shift the tchol_curr_xps backward in time (type='lag')
1757928971180:shift(tchol_curr_xps, type = "lag", n = 3) # by 3 years: 3 years is the duration of efficacy inputs (decrease in tchol and reboud)
1757928971180:}
1757928971181:}, by = pid] #Works!
1757928971182:# test <- sp$pop[pid %in% c(156, 175)]
1757928971182:###############################################################################################################
1757928971183:#--------------------------------------------  Tutorial: End  ------------------------------------------------#
1757928971184:###############################################################################################################
1757928971185:# a variable for new weight after applying efficacy input during treatment influenced period
1757928971185:sp$pop[, new_tchol := {
1757928971186:anchor <- unique(anchor_year)                             # This line finds a single anchor year for each person.
1757928971186:if (is.na(anchor)) {                                      # If no anchor is found,
1757928971187:tchol_curr_xps                                          # the function simply returns the original tchol_curr_xps as-is
1757928971188:} else {                                                  # If yes anchor is found,
1757928971188:fcase(                                                  # We need to assign value to the 'new_tchol' based on the time periods
1757928971189:year < anchor,                       tchol_curr_xps,  # Before anchor year/uptake: original values (including baseline year)
1757928971190:year >= anchor & year <= anchor + 2, baseline_tchol*(1 + tchol_delta),  # During the 2 years where treatment effect manifest
1757928971190:year >= anchor + 3,                  tchol_shift      # After tchol rebound to baseline: revert to the original tchol_curr_xps
1757928971191:)
1757928971191:}
1757928971192:}, by = pid]
1757928971193:# Overwriting the original tchol exposure column with the newly created tchol column
1757928971194:sp$pop[, tchol_curr_xps := new_tchol]
1757928971195:### Jane Aug 2025, test scenario on sp$pop --> Looks like until here everything worked!!!
1757928971196:##################### Get rid of unnecessary variables ##########################
1757928971196:# Delete unnecessary variables from synthpop #
1757928971197:sp$pop[, c("rankstat_sbp", "rankstat_tchol", "ys_rollout", "uptake_rate",
1757928971198:"eligible_bi", "uptake_psyr", "anchor_year",
1757928971198:"entry_year", "baseline_bmi", "bmi_shift", "new_bmi",
1757928971199:"baseline_sbp", "sbp_shift", "new_sbp", "baseline_tchol",
1757928971200:"tchol_shift", "new_tchol") := NULL]
1757928971201:}
1757928971203:# scenario_2_fn(sp) # Works! Aug 25, 2025, Jane
1757928971203:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year >= 25 & eligible_bi ==1, unique(pid)]]
1757928971203:#test_uptake <- sp$pop[pid %in% sp$pop[uptake_one == 1, unique(pid)]]
1757928971203:#test_uptake <- sp$pop[pid %in% sp$pop[entry_year == anchor_year, unique(pid)]]
1757928997385:# Load packages
1757928997386:source("./global.R")
1757929071193:# Load scenario and sensitivity analyses functions
1757929071193:source("./auxil/scenarios_GLP_uncertain.R")
1757929191312:# Initiate .Random.seed for safety
1757929191313:runif(1)
1757929191317:# New runs?
1757929191317:new_runs <- TRUE
1757929191317:new_export <- TRUE
1757929199643:if(new_runs){
1757929199643:# Create batches for batched simulation
1757929199643:batch_size <- 10
1757929199643:iterations <- 5
1757929199644:first_iteration <- 1
1757929199644:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757929199644:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757929199644:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757929199644:}
1757929204358:analysis_name <- "GLP_Test"
1757929204359:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757929336710:if(new_runs){
1757929336710:for(i in batches){
1757929336711:scenario_fn <- scenario_0_fn
1757929336711:IMPACTncd$
1757929336712:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757929336712:scenario_fn <- scenario_1_fn
1757929336712:IMPACTncd$
1757929336713:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757929336713:# scenario_fn <- scenario_2_fn
1757929336713:#
1757929336714:# IMPACTncd$
1757929336714:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757929336714:#
1757929336714:# scenario_fn <- scenario_3_fn
1757929336715:#
1757929336715:# IMPACTncd$
1757929336715:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757929336715:#
1757929336716:# scenario_fn <- scenario_4_fn
1757929336716:#
1757929336716:# IMPACTncd$
1757929336716:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757929336717:}
1757929336717:}
1757929408957:if(new_runs){
1757929408958:for(i in batches){
1757929408958:scenario_fn <- scenario_0_fn
1757929408959:IMPACTncd$
1757929408959:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757929408959:scenario_fn <- scenario_1_fn
1757929408960:IMPACTncd$
1757929408960:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757929408960:# scenario_fn <- scenario_2_fn
1757929408960:#
1757929408961:# IMPACTncd$
1757929408961:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757929408961:#
1757929408961:# scenario_fn <- scenario_3_fn
1757929408962:#
1757929408962:# IMPACTncd$
1757929408962:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757929408962:#
1757929408963:# scenario_fn <- scenario_4_fn
1757929408963:#
1757929408963:# IMPACTncd$
1757929408963:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757929408963:}
1757929408964:}
1757930056918:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757930167919:if(new_runs){
1757930167919:for(i in batches){
1757930167920:scenario_fn <- scenario_0_fn
1757930167920:IMPACTncd$
1757930167920:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757930167920:scenario_fn <- scenario_1_fn
1757930167921:IMPACTncd$
1757930167921:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757930167921:# scenario_fn <- scenario_2_fn
1757930167921:#
1757930167922:# IMPACTncd$
1757930167922:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757930167922:#
1757930167922:# scenario_fn <- scenario_3_fn
1757930167922:#
1757930167922:# IMPACTncd$
1757930167923:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757930167923:#
1757930167923:# scenario_fn <- scenario_4_fn
1757930167923:#
1757930167923:# IMPACTncd$
1757930167923:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757930167924:}
1757930167924:}
1757930599897:# Load packages
1757930599898:source("./global.R")
1757930689466:# Load scenario and sensitivity analyses functions
1757930689466:source("./auxil/scenarios_GLP_uncertain.R")
1757930829875:# Initiate .Random.seed for safety
1757930829876:runif(1)
1757930829877:# New runs?
1757930829877:new_runs <- TRUE
1757930829877:new_export <- TRUE
1757930829878:if(new_runs){
1757930829878:# Create batches for batched simulation
1757930829879:batch_size <- 10
1757930829879:iterations <- 5
1757930829879:first_iteration <- 1
1757930829879:batches <- split(seq(first_iteration, iterations + first_iteration - 1),
1757930829879:f = findInterval(seq(first_iteration, iterations + first_iteration - 1),
1757930829880:vec = seq(first_iteration, iterations + first_iteration - 1, batch_size)))
1757930829880:}
1757930829881:analysis_name <- "GLP_Test"
1757930829881:IMPACTncd <- Simulation$new("./inputs/sim_design_docker.yaml", analysis_name)
1757931118195:if(new_runs){
1757931118196:for(i in batches){
1757931118197:scenario_fn <- scenario_0_fn
1757931118197:IMPACTncd$
1757931118197:run(i, multicore = TRUE, "sc0", m_zero_trend = -0.03, p_zero_trend = 0)
1757931118198:scenario_fn <- scenario_1_fn
1757931118198:IMPACTncd$
1757931118198:run(i, multicore = TRUE, "sc1", m_zero_trend = -0.03, p_zero_trend = 0)
1757931118198:# scenario_fn <- scenario_2_fn
1757931118199:#
1757931118199:# IMPACTncd$
1757931118199:#   run(i, multicore = TRUE, "sc2", m_zero_trend = -0.03, p_zero_trend = 0)
1757931118199:#
1757931118199:# scenario_fn <- scenario_3_fn
1757931118199:#
1757931118200:# IMPACTncd$
1757931118200:#   run(i, multicore = TRUE, "sc3", m_zero_trend = -0.03, p_zero_trend = 0)
1757931118200:#
1757931118200:# scenario_fn <- scenario_4_fn
1757931118200:#
1757931118200:# IMPACTncd$
1757931118200:#   run(i, multicore = TRUE, "sc4", m_zero_trend = -0.03, p_zero_trend = 0)
1757931118201:}
1757931118201:}
1757946303155:View(scenario_0_fn)
1758013201949:View(IMPACTncd)
